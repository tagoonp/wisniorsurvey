/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/jquery-timepicker/jquery-timepicker.js":
/*!*****************************************************!*\
  !*** ./libs/jquery-timepicker/jquery-timepicker.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var timepicker_jquery_timepicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! timepicker/jquery.timepicker */ "./node_modules/timepicker/jquery.timepicker.js");
/* harmony import */ var timepicker_jquery_timepicker__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(timepicker_jquery_timepicker__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./node_modules/timepicker/jquery.timepicker.js":
/*!******************************************************!*\
  !*** ./node_modules/timepicker/jquery.timepicker.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jquery-timepicker v1.13.18 - A jQuery timepicker plugin inspired by Google Calendar. It supports both mouse and keyboard navigation.\n * Copyright (c) 2021 Jon Thornton - https://www.jonthornton.com/jquery-timepicker/\n * License: MIT\n */\n(function () {\n  'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = o[Symbol.iterator]();\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  var ONE_DAY = 86400;\n\n  var roundingFunction = function roundingFunction(seconds, settings) {\n    if (seconds === null) {\n      return null;\n    } else if (typeof settings.step !== \"number\") {\n      // TODO: nearest fit irregular steps\n      return seconds;\n    } else {\n      var _settings$minTime;\n\n      var offset = seconds % (settings.step * 60); // step is in minutes\n\n      var start = (_settings$minTime = settings.minTime()) !== null && _settings$minTime !== void 0 ? _settings$minTime : 0; // adjust offset by start mod step so that the offset is aligned not to 00:00 but to the start\n\n      offset -= start % (settings.step * 60);\n\n      if (offset >= settings.step * 30) {\n        // if offset is larger than a half step, round up\n        seconds += settings.step * 60 - offset;\n      } else {\n        // round down\n        seconds -= offset;\n      }\n\n      return _moduloSeconds(seconds, settings);\n    }\n  };\n\n  function _moduloSeconds(seconds, settings) {\n    if (seconds == ONE_DAY && settings.show2400) {\n      return seconds;\n    }\n\n    return seconds % ONE_DAY;\n  }\n\n  var DEFAULT_SETTINGS = {\n    appendTo: \"body\",\n    className: null,\n    closeOnWindowScroll: false,\n    disableTextInput: false,\n    disableTimeRanges: [],\n    disableTouchKeyboard: false,\n    durationTime: null,\n    forceRoundTime: false,\n    lang: {},\n    listWidth: null,\n    maxTime: null,\n    minTime: null,\n    noneOption: false,\n    orientation: \"l\",\n    roundingFunction: roundingFunction,\n    scrollDefault: null,\n    selectOnBlur: false,\n    show2400: false,\n    showDuration: false,\n    showOn: [\"click\", \"focus\"],\n    showOnFocus: true,\n    step: 30,\n    stopScrollPropagation: false,\n    timeFormat: \"g:ia\",\n    typeaheadHighlight: true,\n    useSelect: false,\n    wrapHours: true\n  };\n  var DEFAULT_LANG = {\n    am: \"am\",\n    pm: \"pm\",\n    AM: \"AM\",\n    PM: \"PM\",\n    decimal: \".\",\n    mins: \"mins\",\n    hr: \"hr\",\n    hrs: \"hrs\"\n  };\n\n  var EVENT_DEFAULTS = {\n    bubbles: true,\n    cancelable: false,\n    detail: null\n  };\n\n  var Timepicker = /*#__PURE__*/function () {\n    function Timepicker(targetEl) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Timepicker);\n\n      this._handleFormatValue = this._handleFormatValue.bind(this);\n      this._handleKeyUp = this._handleKeyUp.bind(this);\n      this.targetEl = targetEl;\n      var attrOptions = Timepicker.extractAttrOptions(targetEl, Object.keys(DEFAULT_SETTINGS));\n      this.settings = this.parseSettings(_objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SETTINGS), options), attrOptions));\n    }\n\n    _createClass(Timepicker, [{\n      key: \"hideMe\",\n      value: function hideMe() {\n        if (this.settings.useSelect) {\n          this.targetEl.blur();\n          return;\n        }\n\n        if (!this.list || !Timepicker.isVisible(this.list)) {\n          return;\n        }\n\n        if (this.settings.selectOnBlur) {\n          this._selectValue();\n        }\n\n        this.list.hide();\n        var hideTimepickerEvent = new CustomEvent('hideTimepicker', EVENT_DEFAULTS);\n        this.targetEl.dispatchEvent(hideTimepickerEvent);\n      }\n    }, {\n      key: \"_findRow\",\n      value: function _findRow(value) {\n        if (!value && value !== 0) {\n          return false;\n        }\n\n        var out = false;\n        var value = this.settings.roundingFunction(value, this.settings);\n\n        if (!this.list) {\n          return false;\n        }\n\n        this.list.find(\"li\").each(function (i, obj) {\n          var parsed = parseInt(obj.dataset.time);\n\n          if (isNaN(parsed)) {\n            return;\n          }\n\n          if (parsed == value) {\n            out = obj;\n            return false;\n          }\n        });\n        return out;\n      }\n    }, {\n      key: \"_hideKeyboard\",\n      value: function _hideKeyboard() {\n        return (window.navigator.msMaxTouchPoints || \"ontouchstart\" in document) && this.settings.disableTouchKeyboard;\n      }\n    }, {\n      key: \"_setTimeValue\",\n      value: function _setTimeValue(value, source) {\n        if (this.targetEl.nodeName === \"INPUT\") {\n          if (value !== null || this.targetEl.value != \"\") {\n            this.targetEl.value = value;\n          }\n\n          var tp = this;\n          var settings = tp.settings;\n\n          if (settings.useSelect && source != \"select\" && tp.list) {\n            tp.list.val(tp._roundAndFormatTime(tp.anytime2int(value)));\n          }\n        }\n\n        var selectTimeEvent = new CustomEvent('selectTime', EVENT_DEFAULTS);\n\n        if (this.selectedValue != value) {\n          this.selectedValue = value;\n          var changeTimeEvent = new CustomEvent('changeTime', EVENT_DEFAULTS);\n          var changeEvent = new CustomEvent('change', Object.assign(EVENT_DEFAULTS, {\n            detail: 'timepicker'\n          }));\n\n          if (source == \"select\") {\n            this.targetEl.dispatchEvent(selectTimeEvent);\n            this.targetEl.dispatchEvent(changeTimeEvent);\n            this.targetEl.dispatchEvent(changeEvent);\n          } else if ([\"error\", \"initial\"].indexOf(source) == -1) {\n            this.targetEl.dispatchEvent(changeTimeEvent);\n          }\n\n          return true;\n        } else {\n          if ([\"error\", \"initial\"].indexOf(source) == -1) {\n            this.targetEl.dispatchEvent(selectTimeEvent);\n          }\n\n          return false;\n        }\n      }\n    }, {\n      key: \"_getTimeValue\",\n      value: function _getTimeValue() {\n        if (this.targetEl.nodeName === \"INPUT\") {\n          return this.targetEl.value;\n        } else {\n          // use the element's data attributes to store values\n          return this.selectedValue;\n        }\n      }\n    }, {\n      key: \"_selectValue\",\n      value: function _selectValue() {\n        var tp = this;\n        tp.settings;\n        var list = tp.list;\n        var cursor = list.find(\".ui-timepicker-selected\");\n\n        if (cursor.hasClass(\"ui-timepicker-disabled\")) {\n          return false;\n        }\n\n        if (!cursor.length) {\n          return true;\n        }\n\n        var timeValue = cursor.get(0).dataset.time; // selected value found\n\n        if (timeValue) {\n          var parsedTimeValue = parseInt(timeValue);\n\n          if (!isNaN(parsedTimeValue)) {\n            timeValue = parsedTimeValue;\n          }\n        }\n\n        if (timeValue !== null) {\n          if (typeof timeValue != \"string\") {\n            timeValue = tp._int2time(timeValue);\n          }\n\n          tp._setTimeValue(timeValue, \"select\");\n        }\n\n        return true;\n      }\n    }, {\n      key: \"anytime2int\",\n      value: function anytime2int(input) {\n        if (typeof input === 'number') {\n          return input;\n        } else if (typeof input === 'string') {\n          return this.time2int(input);\n        } else if (_typeof(input) === 'object' && input instanceof Date) {\n          return input.getHours() * 3600 + input.getMinutes() * 60 + input.getSeconds();\n        } else if (typeof input == 'function') {\n          return input();\n        } else {\n          return null;\n        }\n      }\n    }, {\n      key: \"time2int\",\n      value: function time2int(timeString) {\n        if (timeString === \"\" || timeString === null || timeString === undefined) {\n          return null;\n        }\n\n        if (timeString === 'now') {\n          return this.anytime2int(new Date());\n        }\n\n        if (typeof timeString != \"string\") {\n          return timeString;\n        }\n\n        timeString = timeString.toLowerCase().replace(/[\\s\\.]/g, \"\"); // if the last character is an \"a\" or \"p\", add the \"m\"\n\n        if (timeString.slice(-1) == \"a\" || timeString.slice(-1) == \"p\") {\n          timeString += \"m\";\n        }\n\n        var pattern = /^(([^0-9]*))?([0-9]?[0-9])(([0-5][0-9]))?(([0-5][0-9]))?(([^0-9]*))$/;\n        var hasDelimetersMatch = timeString.match(/\\W/);\n\n        if (hasDelimetersMatch) {\n          pattern = /^(([^0-9]*))?([0-9]?[0-9])(\\W+([0-5][0-9]?))?(\\W+([0-5][0-9]))?(([^0-9]*))$/;\n        }\n\n        var time = timeString.match(pattern);\n\n        if (!time) {\n          return null;\n        }\n\n        var hour = parseInt(time[3] * 1, 10);\n        var ampm = time[2] || time[9];\n        var hours = hour;\n        var minutes = time[5] * 1 || 0;\n        var seconds = time[7] * 1 || 0;\n\n        if (!ampm && time[3].length == 2 && time[3][0] == \"0\") {\n          // preceding '0' implies AM\n          ampm = \"am\";\n        }\n\n        if (hour <= 12 && ampm) {\n          ampm = ampm.trim();\n          var isPm = ampm == this.settings.lang.pm || ampm == this.settings.lang.PM;\n\n          if (hour == 12) {\n            hours = isPm ? 12 : 0;\n          } else {\n            hours = hour + (isPm ? 12 : 0);\n          }\n        } else {\n          var t = hour * 3600 + minutes * 60 + seconds;\n\n          if (t >= ONE_DAY + (this.settings.show2400 ? 1 : 0)) {\n            if (this.settings.wrapHours === false) {\n              return null;\n            }\n\n            hours = hour % 24;\n          }\n        }\n\n        var timeInt = hours * 3600 + minutes * 60 + seconds; // if no am/pm provided, intelligently guess based on the scrollDefault\n\n        if (hour < 12 && !ampm && this.settings._twelveHourTime && this.settings.scrollDefault()) {\n          var delta = timeInt - this.settings.scrollDefault();\n\n          if (delta < 0 && delta >= ONE_DAY / -2) {\n            timeInt = (timeInt + ONE_DAY / 2) % ONE_DAY;\n          }\n        }\n\n        return timeInt;\n      }\n    }, {\n      key: \"intStringDateOrFunc2func\",\n      value: function intStringDateOrFunc2func(input) {\n        var _this = this;\n\n        if (input === null || input === undefined) {\n          return function () {\n            return null;\n          };\n        } else if (typeof input === 'function') {\n          return function () {\n            return _this.anytime2int(input());\n          };\n        } else {\n          return function () {\n            return _this.anytime2int(input);\n          };\n        }\n      }\n    }, {\n      key: \"parseSettings\",\n      value: function parseSettings(settings) {\n        settings.lang = _objectSpread2(_objectSpread2({}, DEFAULT_LANG), settings.lang); // lang is used by other functions the rest of this depends on\n        // todo: unwind circular dependency on lang\n\n        this.settings = settings;\n\n        if (settings.listWidth) {\n          settings.listWidth = this.anytime2int(settings.listWidth);\n        }\n\n        settings.minTime = this.intStringDateOrFunc2func(settings.minTime);\n        settings.maxTime = this.intStringDateOrFunc2func(settings.maxTime);\n        settings.durationTime = this.intStringDateOrFunc2func(settings.durationTime);\n\n        if (settings.scrollDefault) {\n          settings.scrollDefault = this.intStringDateOrFunc2func(settings.scrollDefault);\n        } else {\n          settings.scrollDefault = settings.minTime;\n        }\n\n        if (typeof settings.timeFormat === \"string\" && settings.timeFormat.match(/[gh]/)) {\n          settings._twelveHourTime = true;\n        }\n\n        if (settings.showOnFocus === false && settings.showOn.indexOf(\"focus\") != -1) {\n          settings.showOn.splice(settings.showOn.indexOf(\"focus\"), 1);\n        }\n\n        if (!settings.disableTimeRanges) {\n          settings.disableTimeRanges = [];\n        }\n\n        if (settings.disableTimeRanges.length > 0) {\n          // convert string times to integers\n          for (var i in settings.disableTimeRanges) {\n            settings.disableTimeRanges[i] = [this.anytime2int(settings.disableTimeRanges[i][0]), this.anytime2int(settings.disableTimeRanges[i][1])];\n          } // sort by starting time\n\n\n          settings.disableTimeRanges = settings.disableTimeRanges.sort(function (a, b) {\n            return a[0] - b[0];\n          }); // merge any overlapping ranges\n\n          for (var i = settings.disableTimeRanges.length - 1; i > 0; i--) {\n            if (settings.disableTimeRanges[i][0] <= settings.disableTimeRanges[i - 1][1]) {\n              settings.disableTimeRanges[i - 1] = [Math.min(settings.disableTimeRanges[i][0], settings.disableTimeRanges[i - 1][0]), Math.max(settings.disableTimeRanges[i][1], settings.disableTimeRanges[i - 1][1])];\n              settings.disableTimeRanges.splice(i, 1);\n            }\n          }\n        }\n\n        return settings;\n      }\n      /*\n       *  Filter freeform input\n       */\n\n    }, {\n      key: \"_disableTextInputHandler\",\n      value: function _disableTextInputHandler(e) {\n        switch (e.keyCode) {\n          case 13: // return\n\n          case 9:\n            //tab\n            return;\n\n          default:\n            e.preventDefault();\n        }\n      }\n    }, {\n      key: \"_int2duration\",\n      value: function _int2duration(seconds, step) {\n        seconds = Math.abs(seconds);\n        var minutes = Math.round(seconds / 60),\n            duration = [],\n            hours,\n            mins;\n\n        if (minutes < 60) {\n          // Only show (x mins) under 1 hour\n          duration = [minutes, this.settings.lang.mins];\n        } else {\n          hours = Math.floor(minutes / 60);\n          mins = minutes % 60; // Show decimal notation (eg: 1.5 hrs) for 30 minute steps\n\n          if (step == 30 && mins == 30) {\n            hours += this.settings.lang.decimal + 5;\n          }\n\n          duration.push(hours);\n          duration.push(hours == 1 ? this.settings.lang.hr : this.settings.lang.hrs); // Show remainder minutes notation (eg: 1 hr 15 mins) for non-30 minute steps\n          // and only if there are remainder minutes to show\n\n          if (step != 30 && mins) {\n            duration.push(mins);\n            duration.push(this.settings.lang.mins);\n          }\n        }\n\n        return duration.join(\" \");\n      }\n    }, {\n      key: \"_roundAndFormatTime\",\n      value: function _roundAndFormatTime(seconds) {\n        seconds = this.settings.roundingFunction(seconds, this.settings);\n\n        if (seconds !== null) {\n          return this._int2time(seconds);\n        }\n      }\n    }, {\n      key: \"_int2time\",\n      value: function _int2time(timeInt) {\n        if (typeof timeInt != \"number\") {\n          return null;\n        }\n\n        var seconds = parseInt(timeInt % 60),\n            minutes = parseInt(timeInt / 60 % 60),\n            hours = parseInt(timeInt / (60 * 60) % 24);\n        var time = new Date(1970, 0, 2, hours, minutes, seconds, 0);\n\n        if (isNaN(time.getTime())) {\n          return null;\n        }\n\n        if (typeof this.settings.timeFormat === \"function\") {\n          return this.settings.timeFormat(time);\n        }\n\n        var output = \"\";\n        var hour, code;\n\n        for (var i = 0; i < this.settings.timeFormat.length; i++) {\n          code = this.settings.timeFormat.charAt(i);\n\n          switch (code) {\n            case \"a\":\n              output += time.getHours() > 11 ? this.settings.lang.pm : this.settings.lang.am;\n              break;\n\n            case \"A\":\n              output += time.getHours() > 11 ? this.settings.lang.PM : this.settings.lang.AM;\n              break;\n\n            case \"g\":\n              hour = time.getHours() % 12;\n              output += hour === 0 ? \"12\" : hour;\n              break;\n\n            case \"G\":\n              hour = time.getHours();\n              if (timeInt === ONE_DAY) hour = this.settings.show2400 ? 24 : 0;\n              output += hour;\n              break;\n\n            case \"h\":\n              hour = time.getHours() % 12;\n\n              if (hour !== 0 && hour < 10) {\n                hour = \"0\" + hour;\n              }\n\n              output += hour === 0 ? \"12\" : hour;\n              break;\n\n            case \"H\":\n              hour = time.getHours();\n              if (timeInt === ONE_DAY) hour = this.settings.show2400 ? 24 : 0;\n              output += hour > 9 ? hour : \"0\" + hour;\n              break;\n\n            case \"i\":\n              var minutes = time.getMinutes();\n              output += minutes > 9 ? minutes : \"0\" + minutes;\n              break;\n\n            case \"s\":\n              seconds = time.getSeconds();\n              output += seconds > 9 ? seconds : \"0\" + seconds;\n              break;\n\n            case \"\\\\\":\n              // escape character; add the next character and skip ahead\n              i++;\n              output += this.settings.timeFormat.charAt(i);\n              break;\n\n            default:\n              output += code;\n          }\n        }\n\n        return output;\n      }\n    }, {\n      key: \"_setSelected\",\n      value: function _setSelected() {\n        var list = this.list;\n        list.find(\"li\").removeClass(\"ui-timepicker-selected\");\n        var timeValue = this.anytime2int(this._getTimeValue());\n\n        if (timeValue === null) {\n          return;\n        }\n\n        var selected = this._findRow(timeValue);\n\n        if (selected) {\n          var selectedRect = selected.getBoundingClientRect();\n          var listRect = list.get(0).getBoundingClientRect();\n          var topDelta = selectedRect.top - listRect.top;\n\n          if (topDelta + selectedRect.height > listRect.height || topDelta < 0) {\n            var newScroll = list.scrollTop() + (selectedRect.top - listRect.top) - selectedRect.height;\n            list.scrollTop(newScroll);\n          }\n\n          var parsed = parseInt(selected.dataset.time);\n\n          if (this.settings.forceRoundTime || parsed === timeValue) {\n            selected.classList.add('ui-timepicker-selected');\n          }\n        }\n      }\n    }, {\n      key: \"_isFocused\",\n      value: function _isFocused(el) {\n        return el === document.activeElement;\n      }\n    }, {\n      key: \"_handleFormatValue\",\n      value: function _handleFormatValue(e) {\n        if (e && e.detail == \"timepicker\") {\n          return;\n        }\n\n        this._formatValue(e);\n      }\n    }, {\n      key: \"_formatValue\",\n      value: function _formatValue(e, origin) {\n        if (this.targetEl.value === \"\") {\n          this._setTimeValue(null, origin);\n\n          return;\n        } // IE fires change event before blur\n\n\n        if (this._isFocused(this.targetEl) && (!e || e.type != \"change\")) {\n          return;\n        }\n\n        var settings = this.settings;\n        var seconds = this.anytime2int(this.targetEl.value);\n\n        if (seconds === null) {\n          var timeFormatErrorEvent = new CustomEvent('timeFormatError', EVENT_DEFAULTS);\n          this.targetEl.dispatchEvent(timeFormatErrorEvent);\n          return;\n        }\n\n        var rangeError = false; // check that the time in within bounds\n\n        if (settings.minTime !== null && settings.maxTime !== null && (seconds < settings.minTime() || seconds > settings.maxTime())) {\n          rangeError = true;\n        } // check that time isn't within disabled time ranges\n\n\n        var _iterator = _createForOfIteratorHelper(settings.disableTimeRanges),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var range = _step.value;\n\n            if (seconds >= range[0] && seconds < range[1]) {\n              rangeError = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (settings.forceRoundTime) {\n          var roundSeconds = settings.roundingFunction(seconds, settings);\n\n          if (roundSeconds != seconds) {\n            seconds = roundSeconds;\n            origin = null;\n          }\n        }\n\n        var prettyTime = this._int2time(seconds);\n\n        if (rangeError) {\n          this._setTimeValue(prettyTime);\n\n          var timeRangeErrorEvent = new CustomEvent('timeRangeError', EVENT_DEFAULTS);\n          this.targetEl.dispatchEvent(timeRangeErrorEvent);\n        } else {\n          this._setTimeValue(prettyTime, origin);\n        }\n      }\n    }, {\n      key: \"_generateNoneElement\",\n      value: function _generateNoneElement(optionValue, useSelect) {\n        var label, className, value;\n\n        if (_typeof(optionValue) == \"object\") {\n          label = optionValue.label;\n          className = optionValue.className;\n          value = optionValue.value;\n        } else if (typeof optionValue == \"string\") {\n          label = optionValue;\n          value = \"\";\n        } else {\n          $.error(\"Invalid noneOption value\");\n        }\n\n        var el;\n\n        if (useSelect) {\n          el = document.createElement(\"option\");\n          el.value = value;\n        } else {\n          el = document.createElement(\"li\");\n          el.dataset.time = String(value);\n        }\n\n        el.innerText = label;\n        el.classList.add(className);\n        return el;\n      }\n      /*\n       *  Time typeahead\n       */\n\n    }, {\n      key: \"_handleKeyUp\",\n      value: function _handleKeyUp(e) {\n        var _this2 = this;\n\n        if (!this.list || !Timepicker.isVisible(this.list) || this.settings.disableTextInput) {\n          return true;\n        }\n\n        if (e.type === \"paste\" || e.type === \"cut\") {\n          var handler = function handler() {\n            if (_this2.settings.typeaheadHighlight) {\n              _this2._setSelected();\n            } else {\n              _this2.list.hide();\n            }\n          };\n\n          setTimeout(handler, 0);\n          return;\n        }\n\n        switch (e.keyCode) {\n          case 96: // numpad numerals\n\n          case 97:\n          case 98:\n          case 99:\n          case 100:\n          case 101:\n          case 102:\n          case 103:\n          case 104:\n          case 105:\n          case 48: // numerals\n\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n          case 65: // a\n\n          case 77: // m\n\n          case 80: // p\n\n          case 186: // colon\n\n          case 8: // backspace\n\n          case 46:\n            // delete\n            if (this.settings.typeaheadHighlight) {\n              this._setSelected();\n            } else {\n              this.list.hide();\n            }\n\n            break;\n        }\n      }\n    }], [{\n      key: \"extractAttrOptions\",\n      value: function extractAttrOptions(element, keys) {\n        var output = {};\n\n        var _iterator2 = _createForOfIteratorHelper(keys),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var key = _step2.value;\n\n            if (key in element.dataset) {\n              output[key] = element.dataset[key];\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return output;\n      }\n    }, {\n      key: \"isVisible\",\n      value: function isVisible(elem) {\n        var el = elem[0];\n        return el.offsetWidth > 0 && el.offsetHeight > 0;\n      }\n    }, {\n      key: \"hideAll\",\n      value: function hideAll() {\n        var _iterator3 = _createForOfIteratorHelper(document.getElementsByClassName('ui-timepicker-input')),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var el = _step3.value;\n            var tp = el.timepickerObj;\n\n            if (tp) {\n              tp.hideMe();\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }]);\n\n    return Timepicker;\n  }(); // IE9-11 polyfill for CustomEvent\n\n\n  (function () {\n    if (typeof window.CustomEvent === \"function\") return false;\n\n    function CustomEvent(event, params) {\n      if (!params) {\n        params = {};\n      }\n\n      params = Object.assign(EVENT_DEFAULTS, params);\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    window.CustomEvent = CustomEvent;\n  })();\n\n  (function (factory) {\n    if (( false ? 0 : _typeof(exports)) === \"object\" && exports && ( false ? 0 : _typeof(module)) === \"object\" && module && module.exports === exports) {\n      // Browserify. Attach to jQuery module.\n      factory(__webpack_require__(/*! jquery */ \"jquery\"));\n    } else if (true) {\n      // AMD. Register as an anonymous module.\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n  })(function ($) {\n    var methods = {\n      init: function init(options) {\n        return this.each(function () {\n          var self = $(this);\n          var tp = new Timepicker(this, options);\n          var settings = tp.settings;\n          settings.lang;\n          this.timepickerObj = tp;\n          self.addClass(\"ui-timepicker-input\");\n\n          if (settings.useSelect) {\n            _render(self);\n          } else {\n            self.prop(\"autocomplete\", \"off\");\n\n            if (settings.showOn) {\n              for (var i in settings.showOn) {\n                self.on(settings.showOn[i] + \".timepicker\", methods.show);\n              }\n            }\n\n            self.on(\"change.timepicker\", tp._handleFormatValue);\n            self.on(\"keydown.timepicker\", _keydownhandler);\n            self.on(\"keyup.timepicker\", tp._handleKeyUp);\n\n            if (settings.disableTextInput) {\n              self.on(\"keydown.timepicker\", tp._disableTextInputHandler);\n            }\n\n            self.on(\"cut.timepicker\", tp._handleKeyUp);\n            self.on(\"paste.timepicker\", tp._handleKeyUp);\n\n            tp._formatValue(null, \"initial\");\n          }\n        });\n      },\n      show: function show(e) {\n        var self = $(this);\n        var tp = self[0].timepickerObj;\n        var settings = tp.settings;\n\n        if (e) {\n          e.preventDefault();\n        }\n\n        if (settings.useSelect) {\n          tp.list.trigger('focus');\n          return;\n        }\n\n        if (tp._hideKeyboard()) {\n          // block the keyboard on mobile devices\n          self.trigger('blur');\n        }\n\n        var list = tp.list; // check if input is readonly\n\n        if (self.prop(\"readonly\")) {\n          return;\n        } // check if list needs to be rendered\n\n\n        _render(self);\n\n        list = tp.list;\n\n        if (Timepicker.isVisible(list)) {\n          return;\n        }\n\n        if (self.is('input')) {\n          tp.selectedValue = self.val();\n        }\n\n        tp._setSelected(); // make sure other pickers are hidden\n\n\n        Timepicker.hideAll();\n\n        if (typeof settings.listWidth == \"number\") {\n          list.width(self.outerWidth() * settings.listWidth);\n        } // position the dropdown relative to the input\n\n\n        list.show();\n        var listOffset = {};\n\n        if (settings.orientation.match(/r/)) {\n          // right-align the dropdown\n          listOffset.left = self.offset().left + self.outerWidth() - list.outerWidth() + parseInt(list.css(\"marginLeft\").replace(\"px\", \"\"), 10);\n        } else if (settings.orientation.match(/l/)) {\n          // left-align the dropdown\n          listOffset.left = self.offset().left + parseInt(list.css(\"marginLeft\").replace(\"px\", \"\"), 10);\n        } else if (settings.orientation.match(/c/)) {\n          // center-align the dropdown\n          listOffset.left = self.offset().left + (self.outerWidth() - list.outerWidth()) / 2 + parseInt(list.css(\"marginLeft\").replace(\"px\", \"\"), 10);\n        }\n\n        var verticalOrientation;\n\n        if (settings.orientation.match(/t/)) {\n          verticalOrientation = \"t\";\n        } else if (settings.orientation.match(/b/)) {\n          verticalOrientation = \"b\";\n        } else if (self.offset().top + self.outerHeight(true) + list.outerHeight() > $(window).height() + $(window).scrollTop()) {\n          verticalOrientation = \"t\";\n        } else {\n          verticalOrientation = \"b\";\n        }\n\n        if (verticalOrientation == \"t\") {\n          // position the dropdown on top\n          list.addClass(\"ui-timepicker-positioned-top\");\n          listOffset.top = self.offset().top - list.outerHeight() + parseInt(list.css(\"marginTop\").replace(\"px\", \"\"), 10);\n        } else {\n          // put it under the input\n          list.removeClass(\"ui-timepicker-positioned-top\");\n          listOffset.top = self.offset().top + self.outerHeight() + parseInt(list.css(\"marginTop\").replace(\"px\", \"\"), 10);\n        }\n\n        list.offset(listOffset); // position scrolling\n\n        var selected = list.find(\".ui-timepicker-selected\");\n\n        if (!selected.length) {\n          var timeInt = tp.anytime2int(tp._getTimeValue());\n\n          if (timeInt !== null) {\n            selected = $(tp._findRow(timeInt));\n          } else if (settings.scrollDefault()) {\n            selected = $(tp._findRow(settings.scrollDefault()));\n          }\n        } // if not found or disabled, intelligently find first selectable element\n\n\n        if (!selected.length || selected.hasClass(\"ui-timepicker-disabled\")) {\n          selected = list.find(\"li:not(.ui-timepicker-disabled):first\");\n        }\n\n        if (selected && selected.length) {\n          var topOffset = list.scrollTop() + selected.position().top - selected.outerHeight();\n          list.scrollTop(topOffset);\n        } else {\n          list.scrollTop(0);\n        } // prevent scroll propagation\n\n\n        if (settings.stopScrollPropagation) {\n          $(document).on(\"wheel.ui-timepicker\", \".ui-timepicker-wrapper\", function (e) {\n            e.preventDefault();\n            var currentScroll = $(this).scrollTop();\n            $(this).scrollTop(currentScroll + e.originalEvent.deltaY);\n          });\n        } // attach close handlers\n\n\n        $(document).on(\"mousedown.ui-timepicker\", _closeHandler);\n        window.addEventListener('resize', _closeHandler);\n\n        if (settings.closeOnWindowScroll) {\n          $(document).on(\"scroll.ui-timepicker\", _closeHandler);\n        }\n\n        self.trigger(\"showTimepicker\");\n        return this;\n      },\n      hide: function hide(e) {\n        var tp = this[0].timepickerObj;\n\n        if (tp) {\n          tp.hideMe();\n        }\n\n        Timepicker.hideAll();\n        return this;\n      },\n      option: function option(key, value) {\n        if (typeof key == \"string\" && typeof value == \"undefined\") {\n          var tp = this[0].timepickerObj;\n          return tp.settings[key];\n        }\n\n        return this.each(function () {\n          var self = $(this);\n          var tp = self[0].timepickerObj;\n          var settings = tp.settings;\n          var list = tp.list;\n\n          if (_typeof(key) == \"object\") {\n            settings = $.extend(settings, key);\n          } else if (typeof key == \"string\") {\n            settings[key] = value;\n          }\n\n          settings = tp.parseSettings(settings);\n          tp.settings = settings;\n\n          tp._formatValue({\n            type: \"change\"\n          }, \"initial\");\n\n          if (list) {\n            list.remove();\n            tp.list = null;\n          }\n\n          if (settings.useSelect) {\n            _render(self);\n          }\n        });\n      },\n      getSecondsFromMidnight: function getSecondsFromMidnight() {\n        var tp = this[0].timepickerObj;\n        return tp.anytime2int(tp._getTimeValue());\n      },\n      getTime: function getTime(relative_date) {\n        var tp = this[0].timepickerObj;\n\n        var time_string = tp._getTimeValue();\n\n        if (!time_string) {\n          return null;\n        }\n\n        var offset = tp.anytime2int(time_string);\n\n        if (offset === null) {\n          return null;\n        }\n\n        if (!relative_date) {\n          relative_date = new Date();\n        } // construct a Date from relative date, and offset's time\n\n\n        var time = new Date(relative_date);\n        time.setHours(offset / 3600);\n        time.setMinutes(offset % 3600 / 60);\n        time.setSeconds(offset % 60);\n        time.setMilliseconds(0);\n        return time;\n      },\n      isVisible: function isVisible() {\n        var tp = this[0].timepickerObj;\n        return !!(tp && tp.list && Timepicker.isVisible(tp.list));\n      },\n      setTime: function setTime(value) {\n        var tp = this[0].timepickerObj;\n        var settings = tp.settings;\n\n        if (settings.forceRoundTime) {\n          var prettyTime = tp._roundAndFormatTime(tp.anytime2int(value));\n        } else {\n          var prettyTime = tp._int2time(tp.anytime2int(value));\n        }\n\n        if (value && prettyTime === null && settings.noneOption) {\n          prettyTime = value;\n        }\n\n        tp._setTimeValue(prettyTime, \"initial\");\n\n        tp._formatValue({\n          type: \"change\"\n        }, \"initial\");\n\n        if (tp && tp.list) {\n          tp._setSelected();\n        }\n\n        return this;\n      },\n      remove: function remove() {\n        var self = this; // check if this element is a timepicker\n\n        if (!self.hasClass(\"ui-timepicker-input\")) {\n          return;\n        }\n\n        var tp = self[0].timepickerObj;\n        var settings = tp.settings;\n        self.removeAttr(\"autocomplete\", \"off\");\n        self.removeClass(\"ui-timepicker-input\");\n        self.removeData(\"timepicker-obj\");\n        self.off(\".timepicker\"); // timepicker-list won't be present unless the user has interacted with this timepicker\n\n        if (tp.list) {\n          tp.list.remove();\n        }\n\n        if (settings.useSelect) {\n          self.show();\n        }\n\n        tp.list = null;\n        return this;\n      }\n    }; // private methods\n\n    function _render(self) {\n      var _settings$durationTim, _settings$minTime, _settings$maxTime;\n\n      var tp = self[0].timepickerObj;\n      var list = tp.list;\n      var settings = tp.settings;\n\n      if (list && list.length) {\n        list.remove();\n        tp.list = null;\n      }\n\n      if (settings.useSelect) {\n        list = $(\"<select></select>\", {\n          \"class\": \"ui-timepicker-select\"\n        });\n\n        if (self.attr(\"name\")) {\n          list.attr(\"name\", \"ui-timepicker-\" + self.attr(\"name\"));\n        }\n\n        var wrapped_list = list;\n      } else {\n        list = $(\"<ul></ul>\", {\n          \"class\": \"ui-timepicker-list\"\n        });\n        var wrapped_list = $(\"<div></div>\", {\n          \"class\": \"ui-timepicker-wrapper\",\n          tabindex: -1\n        });\n        wrapped_list.css({\n          display: \"none\",\n          position: \"absolute\"\n        }).append(list);\n      }\n\n      if (settings.noneOption) {\n        if (settings.noneOption === true) {\n          settings.noneOption = settings.useSelect ? \"Time...\" : \"None\";\n        }\n\n        if ($.isArray(settings.noneOption)) {\n          for (var i in settings.noneOption) {\n            if (parseInt(i, 10) == i) {\n              var noneElement = tp._generateNoneElement(settings.noneOption[i], settings.useSelect);\n\n              list.append(noneElement);\n            }\n          }\n        } else {\n          var noneElement = tp._generateNoneElement(settings.noneOption, settings.useSelect);\n\n          list.append(noneElement);\n        }\n      }\n\n      if (settings.className) {\n        wrapped_list.addClass(settings.className);\n      }\n\n      if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {\n        typeof settings.step == \"function\" ? \"function\" : settings.step;\n        wrapped_list.addClass(\"ui-timepicker-with-duration\");\n        wrapped_list.addClass(\"ui-timepicker-step-\" + settings.step);\n      }\n\n      var durStart = (_settings$durationTim = settings.durationTime()) !== null && _settings$durationTim !== void 0 ? _settings$durationTim : settings.minTime();\n      var start = (_settings$minTime = settings.minTime()) !== null && _settings$minTime !== void 0 ? _settings$minTime : 0;\n      var end = (_settings$maxTime = settings.maxTime()) !== null && _settings$maxTime !== void 0 ? _settings$maxTime : start + ONE_DAY - 1;\n\n      if (end < start) {\n        // make sure the end time is greater than start time, otherwise there will be no list to show\n        end += ONE_DAY;\n      }\n\n      if (end === ONE_DAY - 1 && $.type(settings.timeFormat) === \"string\" && settings.show2400) {\n        // show a 24:00 option when using military time\n        end = ONE_DAY;\n      }\n\n      var dr = settings.disableTimeRanges;\n      var drCur = 0;\n      var drLen = dr.length;\n      var stepFunc = settings.step;\n\n      if (typeof stepFunc != \"function\") {\n        stepFunc = function stepFunc() {\n          return settings.step;\n        };\n      }\n\n      for (var i = start, j = 0; i <= end; j++, i += stepFunc(j) * 60) {\n        var timeInt = i;\n\n        var timeString = tp._int2time(timeInt);\n\n        if (settings.useSelect) {\n          var row = $(\"<option></option>\", {\n            value: timeString\n          });\n          row.text(timeString);\n        } else {\n          var row = $(\"<li></li>\");\n          row.addClass(timeInt % ONE_DAY < ONE_DAY / 2 ? \"ui-timepicker-am\" : \"ui-timepicker-pm\");\n          row.attr(\"data-time\", roundingFunction(timeInt, settings));\n          row.text(timeString);\n        }\n\n        if ((settings.minTime() !== null || settings.durationTime() !== null) && settings.showDuration) {\n          var durationString = tp._int2duration(i - durStart, settings.step);\n\n          if (settings.useSelect) {\n            row.text(row.text() + \" (\" + durationString + \")\");\n          } else {\n            var duration = $(\"<span></span>\", {\n              \"class\": \"ui-timepicker-duration\"\n            });\n            duration.text(\" (\" + durationString + \")\");\n            row.append(duration);\n          }\n        }\n\n        if (drCur < drLen) {\n          if (timeInt >= dr[drCur][1]) {\n            drCur += 1;\n          }\n\n          if (dr[drCur] && timeInt >= dr[drCur][0] && timeInt < dr[drCur][1]) {\n            if (settings.useSelect) {\n              row.prop(\"disabled\", true);\n            } else {\n              row.addClass(\"ui-timepicker-disabled\");\n            }\n          }\n        }\n\n        list.append(row);\n      }\n\n      wrapped_list.data(\"timepicker-input\", self);\n      tp.list = wrapped_list;\n\n      if (settings.useSelect) {\n        if (self.val()) {\n          list.val(tp._roundAndFormatTime(tp.anytime2int(self.val())));\n        }\n\n        list.on(\"focus\", function () {\n          $(this).data(\"timepicker-input\").trigger(\"showTimepicker\");\n        });\n        list.on(\"blur\", function () {\n          $(this).data(\"timepicker-input\").trigger(\"hideTimepicker\");\n        });\n        list.on(\"change\", function () {\n          tp._setTimeValue($(this).val(), \"select\");\n        });\n\n        tp._setTimeValue(list.val(), \"initial\");\n\n        self.hide().after(list);\n      } else {\n        var appendTo = settings.appendTo;\n\n        if (typeof appendTo === \"string\") {\n          appendTo = $(appendTo);\n        } else if (typeof appendTo === \"function\") {\n          appendTo = appendTo(self);\n        }\n\n        appendTo.append(wrapped_list);\n\n        tp._setSelected();\n\n        list.on(\"mousedown click\", \"li\", function (e) {\n          // hack: temporarily disable the focus handler\n          // to deal with the fact that IE fires 'focus'\n          // events asynchronously\n          self.off(\"focus.timepicker\");\n          self.on(\"focus.timepicker-ie-hack\", function () {\n            self.off(\"focus.timepicker-ie-hack\");\n            self.on(\"focus.timepicker\", methods.show);\n          });\n\n          if (!tp._hideKeyboard()) {\n            self[0].focus();\n          } // make sure only the clicked row is selected\n\n\n          list.find(\"li\").removeClass(\"ui-timepicker-selected\");\n          $(this).addClass(\"ui-timepicker-selected\");\n\n          if (tp._selectValue()) {\n            self.trigger(\"hideTimepicker\");\n            list.on(\"mouseup.timepicker click.timepicker\", \"li\", function (e) {\n              list.off(\"mouseup.timepicker click.timepicker\");\n              wrapped_list.hide();\n            });\n          }\n        });\n      }\n    } // event handler to decide whether to close timepicker\n\n\n    function _closeHandler(e) {\n      if (e.type == 'focus' && e.target == window) {\n        // mobile Chrome fires focus events against window for some reason\n        return;\n      }\n\n      var target = $(e.target);\n\n      if (target.closest(\".ui-timepicker-input\").length || target.closest(\".ui-timepicker-wrapper\").length) {\n        // active timepicker was focused. ignore\n        return;\n      }\n\n      Timepicker.hideAll();\n      $(document).unbind(\".ui-timepicker\");\n      $(window).unbind(\".ui-timepicker\");\n    }\n    /*\n     *  Keyboard navigation via arrow keys\n     */\n\n\n    function _keydownhandler(e) {\n      var self = $(this);\n      var tp = self[0].timepickerObj;\n      var list = tp.list;\n\n      if (!list || !Timepicker.isVisible(list)) {\n        if (e.keyCode == 40) {\n          // show the list!\n          methods.show.call(self.get(0));\n          list = tp.list;\n\n          if (!tp._hideKeyboard()) {\n            self.trigger('focus');\n          }\n        } else {\n          return true;\n        }\n      }\n\n      switch (e.keyCode) {\n        case 13:\n          // return\n          if (tp._selectValue()) {\n            tp._formatValue({\n              type: \"change\"\n            });\n\n            tp.hideMe();\n          }\n\n          e.preventDefault();\n          return false;\n\n        case 38:\n          // up\n          var selected = list.find(\".ui-timepicker-selected\");\n\n          if (!selected.length) {\n            list.find(\"li\").each(function (i, obj) {\n              if ($(obj).position().top > 0) {\n                selected = $(obj);\n                return false;\n              }\n            });\n            selected.addClass(\"ui-timepicker-selected\");\n          } else if (!selected.is(\":first-child\")) {\n            selected.removeClass(\"ui-timepicker-selected\");\n            selected.prev().addClass(\"ui-timepicker-selected\");\n\n            if (selected.prev().position().top < selected.outerHeight()) {\n              list.scrollTop(list.scrollTop() - selected.outerHeight());\n            }\n          }\n\n          return false;\n\n        case 40:\n          // down\n          selected = list.find(\".ui-timepicker-selected\");\n\n          if (selected.length === 0) {\n            list.find(\"li\").each(function (i, obj) {\n              if ($(obj).position().top > 0) {\n                selected = $(obj);\n                return false;\n              }\n            });\n            selected.addClass(\"ui-timepicker-selected\");\n          } else if (!selected.is(\":last-child\")) {\n            selected.removeClass(\"ui-timepicker-selected\");\n            selected.next().addClass(\"ui-timepicker-selected\");\n\n            if (selected.next().position().top + 2 * selected.outerHeight() > list.outerHeight()) {\n              list.scrollTop(list.scrollTop() + selected.outerHeight());\n            }\n          }\n\n          return false;\n\n        case 27:\n          // escape\n          list.find(\"li\").removeClass(\"ui-timepicker-selected\");\n          tp.hideMe();\n          break;\n\n        case 9:\n          //tab\n          tp.hideMe();\n          break;\n\n        default:\n          return true;\n      }\n    } // Plugin entry\n\n\n    $.fn.timepicker = function (method) {\n      if (!this.length) return this;\n\n      if (methods[method]) {\n        // check if this element is a timepicker\n        if (!this.hasClass(\"ui-timepicker-input\")) {\n          return this;\n        }\n\n        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n      } else if (_typeof(method) === \"object\" || !method) {\n        return methods.init.apply(this, arguments);\n      } else {\n        $.error(\"Method \" + method + \" does not exist on jQuery.timepicker\");\n      }\n    }; // Default plugin options.\n\n\n    $.fn.timepicker.defaults = DEFAULT_SETTINGS;\n  });\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGltZXBpY2tlci9qcXVlcnkudGltZXBpY2tlci5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsbURBQW1EOztBQUVuRCw2SEFBNkg7O0FBRTdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7O0FBRTdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdEQUF3RCxpQ0FBaUM7QUFDekY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0EsV0FBVyxHQUFHOztBQUVkLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzRkFBc0Y7QUFDdEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IscUNBQXFDO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHLElBQUk7OztBQUdQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxTQUFTLE1BQThCLEdBQUcsQ0FBVyxpREFBaUQsTUFBNkIsR0FBRyxDQUFXO0FBQ2pKO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNCQUFRO0FBQzlCLE1BQU0sU0FBUyxJQUEwQztBQUN6RDtBQUNBLE1BQU0saUNBQU8sQ0FBQywyQ0FBUSxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDakMsTUFBTSxLQUFLLEVBR047QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBLFVBQVU7OztBQUdWOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOzs7QUFHM0I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxVQUFVO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsR0FBRzs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU25lYXQvLi9ub2RlX21vZHVsZXMvdGltZXBpY2tlci9qcXVlcnkudGltZXBpY2tlci5qcz8yMDUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICoganF1ZXJ5LXRpbWVwaWNrZXIgdjEuMTMuMTggLSBBIGpRdWVyeSB0aW1lcGlja2VyIHBsdWdpbiBpbnNwaXJlZCBieSBHb29nbGUgQ2FsZW5kYXIuIEl0IHN1cHBvcnRzIGJvdGggbW91c2UgYW5kIGtleWJvYXJkIG5hdmlnYXRpb24uXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgSm9uIFRob3JudG9uIC0gaHR0cHM6Ly93d3cuam9udGhvcm50b24uY29tL2pxdWVyeS10aW1lcGlja2VyL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgIGlmIChpICUgMikge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gICAgdmFyIGl0O1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgczogRixcbiAgICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmOiBGXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsXG4gICAgICAgIGRpZEVyciA9IGZhbHNlLFxuICAgICAgICBlcnI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIH0sXG4gICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgICBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lO1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgIH0sXG4gICAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgICBlcnIgPSBlO1xuICAgICAgfSxcbiAgICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgT05FX0RBWSA9IDg2NDAwO1xuXG4gIHZhciByb3VuZGluZ0Z1bmN0aW9uID0gZnVuY3Rpb24gcm91bmRpbmdGdW5jdGlvbihzZWNvbmRzLCBzZXR0aW5ncykge1xuICAgIGlmIChzZWNvbmRzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXR0aW5ncy5zdGVwICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAvLyBUT0RPOiBuZWFyZXN0IGZpdCBpcnJlZ3VsYXIgc3RlcHNcbiAgICAgIHJldHVybiBzZWNvbmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3NldHRpbmdzJG1pblRpbWU7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBzZWNvbmRzICUgKHNldHRpbmdzLnN0ZXAgKiA2MCk7IC8vIHN0ZXAgaXMgaW4gbWludXRlc1xuXG4gICAgICB2YXIgc3RhcnQgPSAoX3NldHRpbmdzJG1pblRpbWUgPSBzZXR0aW5ncy5taW5UaW1lKCkpICE9PSBudWxsICYmIF9zZXR0aW5ncyRtaW5UaW1lICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkbWluVGltZSA6IDA7IC8vIGFkanVzdCBvZmZzZXQgYnkgc3RhcnQgbW9kIHN0ZXAgc28gdGhhdCB0aGUgb2Zmc2V0IGlzIGFsaWduZWQgbm90IHRvIDAwOjAwIGJ1dCB0byB0aGUgc3RhcnRcblxuICAgICAgb2Zmc2V0IC09IHN0YXJ0ICUgKHNldHRpbmdzLnN0ZXAgKiA2MCk7XG5cbiAgICAgIGlmIChvZmZzZXQgPj0gc2V0dGluZ3Muc3RlcCAqIDMwKSB7XG4gICAgICAgIC8vIGlmIG9mZnNldCBpcyBsYXJnZXIgdGhhbiBhIGhhbGYgc3RlcCwgcm91bmQgdXBcbiAgICAgICAgc2Vjb25kcyArPSBzZXR0aW5ncy5zdGVwICogNjAgLSBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByb3VuZCBkb3duXG4gICAgICAgIHNlY29uZHMgLT0gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX21vZHVsb1NlY29uZHMoc2Vjb25kcywgc2V0dGluZ3MpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBfbW9kdWxvU2Vjb25kcyhzZWNvbmRzLCBzZXR0aW5ncykge1xuICAgIGlmIChzZWNvbmRzID09IE9ORV9EQVkgJiYgc2V0dGluZ3Muc2hvdzI0MDApIHtcbiAgICAgIHJldHVybiBzZWNvbmRzO1xuICAgIH1cblxuICAgIHJldHVybiBzZWNvbmRzICUgT05FX0RBWTtcbiAgfVxuXG4gIHZhciBERUZBVUxUX1NFVFRJTkdTID0ge1xuICAgIGFwcGVuZFRvOiBcImJvZHlcIixcbiAgICBjbGFzc05hbWU6IG51bGwsXG4gICAgY2xvc2VPbldpbmRvd1Njcm9sbDogZmFsc2UsXG4gICAgZGlzYWJsZVRleHRJbnB1dDogZmFsc2UsXG4gICAgZGlzYWJsZVRpbWVSYW5nZXM6IFtdLFxuICAgIGRpc2FibGVUb3VjaEtleWJvYXJkOiBmYWxzZSxcbiAgICBkdXJhdGlvblRpbWU6IG51bGwsXG4gICAgZm9yY2VSb3VuZFRpbWU6IGZhbHNlLFxuICAgIGxhbmc6IHt9LFxuICAgIGxpc3RXaWR0aDogbnVsbCxcbiAgICBtYXhUaW1lOiBudWxsLFxuICAgIG1pblRpbWU6IG51bGwsXG4gICAgbm9uZU9wdGlvbjogZmFsc2UsXG4gICAgb3JpZW50YXRpb246IFwibFwiLFxuICAgIHJvdW5kaW5nRnVuY3Rpb246IHJvdW5kaW5nRnVuY3Rpb24sXG4gICAgc2Nyb2xsRGVmYXVsdDogbnVsbCxcbiAgICBzZWxlY3RPbkJsdXI6IGZhbHNlLFxuICAgIHNob3cyNDAwOiBmYWxzZSxcbiAgICBzaG93RHVyYXRpb246IGZhbHNlLFxuICAgIHNob3dPbjogW1wiY2xpY2tcIiwgXCJmb2N1c1wiXSxcbiAgICBzaG93T25Gb2N1czogdHJ1ZSxcbiAgICBzdGVwOiAzMCxcbiAgICBzdG9wU2Nyb2xsUHJvcGFnYXRpb246IGZhbHNlLFxuICAgIHRpbWVGb3JtYXQ6IFwiZzppYVwiLFxuICAgIHR5cGVhaGVhZEhpZ2hsaWdodDogdHJ1ZSxcbiAgICB1c2VTZWxlY3Q6IGZhbHNlLFxuICAgIHdyYXBIb3VyczogdHJ1ZVxuICB9O1xuICB2YXIgREVGQVVMVF9MQU5HID0ge1xuICAgIGFtOiBcImFtXCIsXG4gICAgcG06IFwicG1cIixcbiAgICBBTTogXCJBTVwiLFxuICAgIFBNOiBcIlBNXCIsXG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgbWluczogXCJtaW5zXCIsXG4gICAgaHI6IFwiaHJcIixcbiAgICBocnM6IFwiaHJzXCJcbiAgfTtcblxuICB2YXIgRVZFTlRfREVGQVVMVFMgPSB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICBkZXRhaWw6IG51bGxcbiAgfTtcblxuICB2YXIgVGltZXBpY2tlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZXBpY2tlcih0YXJnZXRFbCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZXBpY2tlcik7XG5cbiAgICAgIHRoaXMuX2hhbmRsZUZvcm1hdFZhbHVlID0gdGhpcy5faGFuZGxlRm9ybWF0VmFsdWUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2hhbmRsZUtleVVwID0gdGhpcy5faGFuZGxlS2V5VXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMudGFyZ2V0RWwgPSB0YXJnZXRFbDtcbiAgICAgIHZhciBhdHRyT3B0aW9ucyA9IFRpbWVwaWNrZXIuZXh0cmFjdEF0dHJPcHRpb25zKHRhcmdldEVsLCBPYmplY3Qua2V5cyhERUZBVUxUX1NFVFRJTkdTKSk7XG4gICAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5wYXJzZVNldHRpbmdzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX1NFVFRJTkdTKSwgb3B0aW9ucyksIGF0dHJPcHRpb25zKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFRpbWVwaWNrZXIsIFt7XG4gICAgICBrZXk6IFwiaGlkZU1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZU1lKCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy51c2VTZWxlY3QpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldEVsLmJsdXIoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubGlzdCB8fCAhVGltZXBpY2tlci5pc1Zpc2libGUodGhpcy5saXN0KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE9uQmx1cikge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpc3QuaGlkZSgpO1xuICAgICAgICB2YXIgaGlkZVRpbWVwaWNrZXJFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnaGlkZVRpbWVwaWNrZXInLCBFVkVOVF9ERUZBVUxUUyk7XG4gICAgICAgIHRoaXMudGFyZ2V0RWwuZGlzcGF0Y2hFdmVudChoaWRlVGltZXBpY2tlckV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2ZpbmRSb3dcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZFJvdyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dCA9IGZhbHNlO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNldHRpbmdzLnJvdW5kaW5nRnVuY3Rpb24odmFsdWUsIHRoaXMuc2V0dGluZ3MpO1xuXG4gICAgICAgIGlmICghdGhpcy5saXN0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saXN0LmZpbmQoXCJsaVwiKS5lYWNoKGZ1bmN0aW9uIChpLCBvYmopIHtcbiAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQob2JqLmRhdGFzZXQudGltZSk7XG5cbiAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJzZWQgPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG91dCA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaGlkZUtleWJvYXJkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGVLZXlib2FyZCgpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgfHwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudCkgJiYgdGhpcy5zZXR0aW5ncy5kaXNhYmxlVG91Y2hLZXlib2FyZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NldFRpbWVWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRUaW1lVmFsdWUodmFsdWUsIHNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy50YXJnZXRFbC5ub2RlTmFtZSA9PT0gXCJJTlBVVFwiKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsIHx8IHRoaXMudGFyZ2V0RWwudmFsdWUgIT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0cCA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNldHRpbmdzID0gdHAuc2V0dGluZ3M7XG5cbiAgICAgICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0ICYmIHNvdXJjZSAhPSBcInNlbGVjdFwiICYmIHRwLmxpc3QpIHtcbiAgICAgICAgICAgIHRwLmxpc3QudmFsKHRwLl9yb3VuZEFuZEZvcm1hdFRpbWUodHAuYW55dGltZTJpbnQodmFsdWUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdFRpbWVFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnc2VsZWN0VGltZScsIEVWRU5UX0RFRkFVTFRTKTtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdmFyIGNoYW5nZVRpbWVFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2hhbmdlVGltZScsIEVWRU5UX0RFRkFVTFRTKTtcbiAgICAgICAgICB2YXIgY2hhbmdlRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NoYW5nZScsIE9iamVjdC5hc3NpZ24oRVZFTlRfREVGQVVMVFMsIHtcbiAgICAgICAgICAgIGRldGFpbDogJ3RpbWVwaWNrZXInXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgaWYgKHNvdXJjZSA9PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEVsLmRpc3BhdGNoRXZlbnQoc2VsZWN0VGltZUV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RWwuZGlzcGF0Y2hFdmVudChjaGFuZ2VUaW1lRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbC5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFtcImVycm9yXCIsIFwiaW5pdGlhbFwiXS5pbmRleE9mKHNvdXJjZSkgPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RWwuZGlzcGF0Y2hFdmVudChjaGFuZ2VUaW1lRXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChbXCJlcnJvclwiLCBcImluaXRpYWxcIl0uaW5kZXhPZihzb3VyY2UpID09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldEVsLmRpc3BhdGNoRXZlbnQoc2VsZWN0VGltZUV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldFRpbWVWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUaW1lVmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldEVsLm5vZGVOYW1lID09PSBcIklOUFVUXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRFbC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2UgdGhlIGVsZW1lbnQncyBkYXRhIGF0dHJpYnV0ZXMgdG8gc3RvcmUgdmFsdWVzXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2VsZWN0VmFsdWVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0VmFsdWUoKSB7XG4gICAgICAgIHZhciB0cCA9IHRoaXM7XG4gICAgICAgIHRwLnNldHRpbmdzO1xuICAgICAgICB2YXIgbGlzdCA9IHRwLmxpc3Q7XG4gICAgICAgIHZhciBjdXJzb3IgPSBsaXN0LmZpbmQoXCIudWktdGltZXBpY2tlci1zZWxlY3RlZFwiKTtcblxuICAgICAgICBpZiAoY3Vyc29yLmhhc0NsYXNzKFwidWktdGltZXBpY2tlci1kaXNhYmxlZFwiKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3Vyc29yLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRpbWVWYWx1ZSA9IGN1cnNvci5nZXQoMCkuZGF0YXNldC50aW1lOyAvLyBzZWxlY3RlZCB2YWx1ZSBmb3VuZFxuXG4gICAgICAgIGlmICh0aW1lVmFsdWUpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkVGltZVZhbHVlID0gcGFyc2VJbnQodGltZVZhbHVlKTtcblxuICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VkVGltZVZhbHVlKSkge1xuICAgICAgICAgICAgdGltZVZhbHVlID0gcGFyc2VkVGltZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRpbWVWYWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aW1lVmFsdWUgPSB0cC5faW50MnRpbWUodGltZVZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cC5fc2V0VGltZVZhbHVlKHRpbWVWYWx1ZSwgXCJzZWxlY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYW55dGltZTJpbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnl0aW1lMmludChpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGltZTJpbnQoaW5wdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0JyAmJiBpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXQuZ2V0SG91cnMoKSAqIDM2MDAgKyBpbnB1dC5nZXRNaW51dGVzKCkgKiA2MCArIGlucHV0LmdldFNlY29uZHMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnB1dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRpbWUyaW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdGltZTJpbnQodGltZVN0cmluZykge1xuICAgICAgICBpZiAodGltZVN0cmluZyA9PT0gXCJcIiB8fCB0aW1lU3RyaW5nID09PSBudWxsIHx8IHRpbWVTdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWVTdHJpbmcgPT09ICdub3cnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYW55dGltZTJpbnQobmV3IERhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRpbWVTdHJpbmcgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB0aW1lU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZVN0cmluZyA9IHRpbWVTdHJpbmcudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXFxzXFwuXS9nLCBcIlwiKTsgLy8gaWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGFuIFwiYVwiIG9yIFwicFwiLCBhZGQgdGhlIFwibVwiXG5cbiAgICAgICAgaWYgKHRpbWVTdHJpbmcuc2xpY2UoLTEpID09IFwiYVwiIHx8IHRpbWVTdHJpbmcuc2xpY2UoLTEpID09IFwicFwiKSB7XG4gICAgICAgICAgdGltZVN0cmluZyArPSBcIm1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXR0ZXJuID0gL14oKFteMC05XSopKT8oWzAtOV0/WzAtOV0pKChbMC01XVswLTldKSk/KChbMC01XVswLTldKSk/KChbXjAtOV0qKSkkLztcbiAgICAgICAgdmFyIGhhc0RlbGltZXRlcnNNYXRjaCA9IHRpbWVTdHJpbmcubWF0Y2goL1xcVy8pO1xuXG4gICAgICAgIGlmIChoYXNEZWxpbWV0ZXJzTWF0Y2gpIHtcbiAgICAgICAgICBwYXR0ZXJuID0gL14oKFteMC05XSopKT8oWzAtOV0/WzAtOV0pKFxcVysoWzAtNV1bMC05XT8pKT8oXFxXKyhbMC01XVswLTldKSk/KChbXjAtOV0qKSkkLztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0aW1lID0gdGltZVN0cmluZy5tYXRjaChwYXR0ZXJuKTtcblxuICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBob3VyID0gcGFyc2VJbnQodGltZVszXSAqIDEsIDEwKTtcbiAgICAgICAgdmFyIGFtcG0gPSB0aW1lWzJdIHx8IHRpbWVbOV07XG4gICAgICAgIHZhciBob3VycyA9IGhvdXI7XG4gICAgICAgIHZhciBtaW51dGVzID0gdGltZVs1XSAqIDEgfHwgMDtcbiAgICAgICAgdmFyIHNlY29uZHMgPSB0aW1lWzddICogMSB8fCAwO1xuXG4gICAgICAgIGlmICghYW1wbSAmJiB0aW1lWzNdLmxlbmd0aCA9PSAyICYmIHRpbWVbM11bMF0gPT0gXCIwXCIpIHtcbiAgICAgICAgICAvLyBwcmVjZWRpbmcgJzAnIGltcGxpZXMgQU1cbiAgICAgICAgICBhbXBtID0gXCJhbVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhvdXIgPD0gMTIgJiYgYW1wbSkge1xuICAgICAgICAgIGFtcG0gPSBhbXBtLnRyaW0oKTtcbiAgICAgICAgICB2YXIgaXNQbSA9IGFtcG0gPT0gdGhpcy5zZXR0aW5ncy5sYW5nLnBtIHx8IGFtcG0gPT0gdGhpcy5zZXR0aW5ncy5sYW5nLlBNO1xuXG4gICAgICAgICAgaWYgKGhvdXIgPT0gMTIpIHtcbiAgICAgICAgICAgIGhvdXJzID0gaXNQbSA/IDEyIDogMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG91cnMgPSBob3VyICsgKGlzUG0gPyAxMiA6IDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdCA9IGhvdXIgKiAzNjAwICsgbWludXRlcyAqIDYwICsgc2Vjb25kcztcblxuICAgICAgICAgIGlmICh0ID49IE9ORV9EQVkgKyAodGhpcy5zZXR0aW5ncy5zaG93MjQwMCA/IDEgOiAwKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mud3JhcEhvdXJzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG91cnMgPSBob3VyICUgMjQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRpbWVJbnQgPSBob3VycyAqIDM2MDAgKyBtaW51dGVzICogNjAgKyBzZWNvbmRzOyAvLyBpZiBubyBhbS9wbSBwcm92aWRlZCwgaW50ZWxsaWdlbnRseSBndWVzcyBiYXNlZCBvbiB0aGUgc2Nyb2xsRGVmYXVsdFxuXG4gICAgICAgIGlmIChob3VyIDwgMTIgJiYgIWFtcG0gJiYgdGhpcy5zZXR0aW5ncy5fdHdlbHZlSG91clRpbWUgJiYgdGhpcy5zZXR0aW5ncy5zY3JvbGxEZWZhdWx0KCkpIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSB0aW1lSW50IC0gdGhpcy5zZXR0aW5ncy5zY3JvbGxEZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoZGVsdGEgPCAwICYmIGRlbHRhID49IE9ORV9EQVkgLyAtMikge1xuICAgICAgICAgICAgdGltZUludCA9ICh0aW1lSW50ICsgT05FX0RBWSAvIDIpICUgT05FX0RBWTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGltZUludDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW50U3RyaW5nRGF0ZU9yRnVuYzJmdW5jXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW50U3RyaW5nRGF0ZU9yRnVuYzJmdW5jKGlucHV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFueXRpbWUyaW50KGlucHV0KCkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hbnl0aW1lMmludChpbnB1dCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYXJzZVNldHRpbmdzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncy5sYW5nID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfTEFORyksIHNldHRpbmdzLmxhbmcpOyAvLyBsYW5nIGlzIHVzZWQgYnkgb3RoZXIgZnVuY3Rpb25zIHRoZSByZXN0IG9mIHRoaXMgZGVwZW5kcyBvblxuICAgICAgICAvLyB0b2RvOiB1bndpbmQgY2lyY3VsYXIgZGVwZW5kZW5jeSBvbiBsYW5nXG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5saXN0V2lkdGgpIHtcbiAgICAgICAgICBzZXR0aW5ncy5saXN0V2lkdGggPSB0aGlzLmFueXRpbWUyaW50KHNldHRpbmdzLmxpc3RXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5taW5UaW1lID0gdGhpcy5pbnRTdHJpbmdEYXRlT3JGdW5jMmZ1bmMoc2V0dGluZ3MubWluVGltZSk7XG4gICAgICAgIHNldHRpbmdzLm1heFRpbWUgPSB0aGlzLmludFN0cmluZ0RhdGVPckZ1bmMyZnVuYyhzZXR0aW5ncy5tYXhUaW1lKTtcbiAgICAgICAgc2V0dGluZ3MuZHVyYXRpb25UaW1lID0gdGhpcy5pbnRTdHJpbmdEYXRlT3JGdW5jMmZ1bmMoc2V0dGluZ3MuZHVyYXRpb25UaW1lKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3Muc2Nyb2xsRGVmYXVsdCkge1xuICAgICAgICAgIHNldHRpbmdzLnNjcm9sbERlZmF1bHQgPSB0aGlzLmludFN0cmluZ0RhdGVPckZ1bmMyZnVuYyhzZXR0aW5ncy5zY3JvbGxEZWZhdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0aW5ncy5zY3JvbGxEZWZhdWx0ID0gc2V0dGluZ3MubWluVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MudGltZUZvcm1hdCA9PT0gXCJzdHJpbmdcIiAmJiBzZXR0aW5ncy50aW1lRm9ybWF0Lm1hdGNoKC9bZ2hdLykpIHtcbiAgICAgICAgICBzZXR0aW5ncy5fdHdlbHZlSG91clRpbWUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnNob3dPbkZvY3VzID09PSBmYWxzZSAmJiBzZXR0aW5ncy5zaG93T24uaW5kZXhPZihcImZvY3VzXCIpICE9IC0xKSB7XG4gICAgICAgICAgc2V0dGluZ3Muc2hvd09uLnNwbGljZShzZXR0aW5ncy5zaG93T24uaW5kZXhPZihcImZvY3VzXCIpLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMpIHtcbiAgICAgICAgICBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyB0aW1lcyB0byBpbnRlZ2Vyc1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ldID0gW3RoaXMuYW55dGltZTJpbnQoc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaV1bMF0pLCB0aGlzLmFueXRpbWUyaW50KHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2ldWzFdKV07XG4gICAgICAgICAgfSAvLyBzb3J0IGJ5IHN0YXJ0aW5nIHRpbWVcblxuXG4gICAgICAgICAgc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXMgPSBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgICAgICAgfSk7IC8vIG1lcmdlIGFueSBvdmVybGFwcGluZyByYW5nZXNcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaV1bMF0gPD0gc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaSAtIDFdWzFdKSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2kgLSAxXSA9IFtNYXRoLm1pbihzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlc1tpXVswXSwgc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaSAtIDFdWzBdKSwgTWF0aC5tYXgoc2V0dGluZ3MuZGlzYWJsZVRpbWVSYW5nZXNbaV1bMV0sIHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzW2kgLSAxXVsxXSldO1xuICAgICAgICAgICAgICBzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqICBGaWx0ZXIgZnJlZWZvcm0gaW5wdXRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiBcIl9kaXNhYmxlVGV4dElucHV0SGFuZGxlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXNhYmxlVGV4dElucHV0SGFuZGxlcihlKSB7XG4gICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgY2FzZSAxMzogLy8gcmV0dXJuXG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAvL3RhYlxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaW50MmR1cmF0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2ludDJkdXJhdGlvbihzZWNvbmRzLCBzdGVwKSB7XG4gICAgICAgIHNlY29uZHMgPSBNYXRoLmFicyhzZWNvbmRzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSBNYXRoLnJvdW5kKHNlY29uZHMgLyA2MCksXG4gICAgICAgICAgICBkdXJhdGlvbiA9IFtdLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICBtaW5zO1xuXG4gICAgICAgIGlmIChtaW51dGVzIDwgNjApIHtcbiAgICAgICAgICAvLyBPbmx5IHNob3cgKHggbWlucykgdW5kZXIgMSBob3VyXG4gICAgICAgICAgZHVyYXRpb24gPSBbbWludXRlcywgdGhpcy5zZXR0aW5ncy5sYW5nLm1pbnNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhvdXJzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICAgIG1pbnMgPSBtaW51dGVzICUgNjA7IC8vIFNob3cgZGVjaW1hbCBub3RhdGlvbiAoZWc6IDEuNSBocnMpIGZvciAzMCBtaW51dGUgc3RlcHNcblxuICAgICAgICAgIGlmIChzdGVwID09IDMwICYmIG1pbnMgPT0gMzApIHtcbiAgICAgICAgICAgIGhvdXJzICs9IHRoaXMuc2V0dGluZ3MubGFuZy5kZWNpbWFsICsgNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkdXJhdGlvbi5wdXNoKGhvdXJzKTtcbiAgICAgICAgICBkdXJhdGlvbi5wdXNoKGhvdXJzID09IDEgPyB0aGlzLnNldHRpbmdzLmxhbmcuaHIgOiB0aGlzLnNldHRpbmdzLmxhbmcuaHJzKTsgLy8gU2hvdyByZW1haW5kZXIgbWludXRlcyBub3RhdGlvbiAoZWc6IDEgaHIgMTUgbWlucykgZm9yIG5vbi0zMCBtaW51dGUgc3RlcHNcbiAgICAgICAgICAvLyBhbmQgb25seSBpZiB0aGVyZSBhcmUgcmVtYWluZGVyIG1pbnV0ZXMgdG8gc2hvd1xuXG4gICAgICAgICAgaWYgKHN0ZXAgIT0gMzAgJiYgbWlucykge1xuICAgICAgICAgICAgZHVyYXRpb24ucHVzaChtaW5zKTtcbiAgICAgICAgICAgIGR1cmF0aW9uLnB1c2godGhpcy5zZXR0aW5ncy5sYW5nLm1pbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5qb2luKFwiIFwiKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3JvdW5kQW5kRm9ybWF0VGltZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yb3VuZEFuZEZvcm1hdFRpbWUoc2Vjb25kcykge1xuICAgICAgICBzZWNvbmRzID0gdGhpcy5zZXR0aW5ncy5yb3VuZGluZ0Z1bmN0aW9uKHNlY29uZHMsIHRoaXMuc2V0dGluZ3MpO1xuXG4gICAgICAgIGlmIChzZWNvbmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ludDJ0aW1lKHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9pbnQydGltZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnQydGltZSh0aW1lSW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGltZUludCAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IHBhcnNlSW50KHRpbWVJbnQgJSA2MCksXG4gICAgICAgICAgICBtaW51dGVzID0gcGFyc2VJbnQodGltZUludCAvIDYwICUgNjApLFxuICAgICAgICAgICAgaG91cnMgPSBwYXJzZUludCh0aW1lSW50IC8gKDYwICogNjApICUgMjQpO1xuICAgICAgICB2YXIgdGltZSA9IG5ldyBEYXRlKDE5NzAsIDAsIDIsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCAwKTtcblxuICAgICAgICBpZiAoaXNOYU4odGltZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2V0dGluZ3MudGltZUZvcm1hdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudGltZUZvcm1hdCh0aW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRwdXQgPSBcIlwiO1xuICAgICAgICB2YXIgaG91ciwgY29kZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2V0dGluZ3MudGltZUZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvZGUgPSB0aGlzLnNldHRpbmdzLnRpbWVGb3JtYXQuY2hhckF0KGkpO1xuXG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgICAgICBvdXRwdXQgKz0gdGltZS5nZXRIb3VycygpID4gMTEgPyB0aGlzLnNldHRpbmdzLmxhbmcucG0gOiB0aGlzLnNldHRpbmdzLmxhbmcuYW07XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgICBvdXRwdXQgKz0gdGltZS5nZXRIb3VycygpID4gMTEgPyB0aGlzLnNldHRpbmdzLmxhbmcuUE0gOiB0aGlzLnNldHRpbmdzLmxhbmcuQU07XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICAgICAgICBob3VyID0gdGltZS5nZXRIb3VycygpICUgMTI7XG4gICAgICAgICAgICAgIG91dHB1dCArPSBob3VyID09PSAwID8gXCIxMlwiIDogaG91cjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJHXCI6XG4gICAgICAgICAgICAgIGhvdXIgPSB0aW1lLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgIGlmICh0aW1lSW50ID09PSBPTkVfREFZKSBob3VyID0gdGhpcy5zZXR0aW5ncy5zaG93MjQwMCA/IDI0IDogMDtcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IGhvdXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgICBob3VyID0gdGltZS5nZXRIb3VycygpICUgMTI7XG5cbiAgICAgICAgICAgICAgaWYgKGhvdXIgIT09IDAgJiYgaG91ciA8IDEwKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IFwiMFwiICsgaG91cjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dHB1dCArPSBob3VyID09PSAwID8gXCIxMlwiIDogaG91cjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgIGhvdXIgPSB0aW1lLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgIGlmICh0aW1lSW50ID09PSBPTkVfREFZKSBob3VyID0gdGhpcy5zZXR0aW5ncy5zaG93MjQwMCA/IDI0IDogMDtcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IGhvdXIgPiA5ID8gaG91ciA6IFwiMFwiICsgaG91cjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgICAgICAgIHZhciBtaW51dGVzID0gdGltZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgICAgIG91dHB1dCArPSBtaW51dGVzID4gOSA/IG1pbnV0ZXMgOiBcIjBcIiArIG1pbnV0ZXM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICBzZWNvbmRzID0gdGltZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICAgIG91dHB1dCArPSBzZWNvbmRzID4gOSA/IHNlY29uZHMgOiBcIjBcIiArIHNlY29uZHM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAvLyBlc2NhcGUgY2hhcmFjdGVyOyBhZGQgdGhlIG5leHQgY2hhcmFjdGVyIGFuZCBza2lwIGFoZWFkXG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgb3V0cHV0ICs9IHRoaXMuc2V0dGluZ3MudGltZUZvcm1hdC5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBvdXRwdXQgKz0gY29kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0U2VsZWN0ZWRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2VsZWN0ZWQoKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0O1xuICAgICAgICBsaXN0LmZpbmQoXCJsaVwiKS5yZW1vdmVDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG4gICAgICAgIHZhciB0aW1lVmFsdWUgPSB0aGlzLmFueXRpbWUyaW50KHRoaXMuX2dldFRpbWVWYWx1ZSgpKTtcblxuICAgICAgICBpZiAodGltZVZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkID0gdGhpcy5fZmluZFJvdyh0aW1lVmFsdWUpO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgIHZhciBzZWxlY3RlZFJlY3QgPSBzZWxlY3RlZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgbGlzdFJlY3QgPSBsaXN0LmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgdG9wRGVsdGEgPSBzZWxlY3RlZFJlY3QudG9wIC0gbGlzdFJlY3QudG9wO1xuXG4gICAgICAgICAgaWYgKHRvcERlbHRhICsgc2VsZWN0ZWRSZWN0LmhlaWdodCA+IGxpc3RSZWN0LmhlaWdodCB8fCB0b3BEZWx0YSA8IDApIHtcbiAgICAgICAgICAgIHZhciBuZXdTY3JvbGwgPSBsaXN0LnNjcm9sbFRvcCgpICsgKHNlbGVjdGVkUmVjdC50b3AgLSBsaXN0UmVjdC50b3ApIC0gc2VsZWN0ZWRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIGxpc3Quc2Nyb2xsVG9wKG5ld1Njcm9sbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHNlbGVjdGVkLmRhdGFzZXQudGltZSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5mb3JjZVJvdW5kVGltZSB8fCBwYXJzZWQgPT09IHRpbWVWYWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQuY2xhc3NMaXN0LmFkZCgndWktdGltZXBpY2tlci1zZWxlY3RlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfaXNGb2N1c2VkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzRm9jdXNlZChlbCkge1xuICAgICAgICByZXR1cm4gZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9oYW5kbGVGb3JtYXRWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVGb3JtYXRWYWx1ZShlKSB7XG4gICAgICAgIGlmIChlICYmIGUuZGV0YWlsID09IFwidGltZXBpY2tlclwiKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZm9ybWF0VmFsdWUoZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9mb3JtYXRWYWx1ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9mb3JtYXRWYWx1ZShlLCBvcmlnaW4pIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0RWwudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aGlzLl9zZXRUaW1lVmFsdWUobnVsbCwgb3JpZ2luKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBJRSBmaXJlcyBjaGFuZ2UgZXZlbnQgYmVmb3JlIGJsdXJcblxuXG4gICAgICAgIGlmICh0aGlzLl9pc0ZvY3VzZWQodGhpcy50YXJnZXRFbCkgJiYgKCFlIHx8IGUudHlwZSAhPSBcImNoYW5nZVwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgIHZhciBzZWNvbmRzID0gdGhpcy5hbnl0aW1lMmludCh0aGlzLnRhcmdldEVsLnZhbHVlKTtcblxuICAgICAgICBpZiAoc2Vjb25kcyA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0aW1lRm9ybWF0RXJyb3JFdmVudCA9IG5ldyBDdXN0b21FdmVudCgndGltZUZvcm1hdEVycm9yJywgRVZFTlRfREVGQVVMVFMpO1xuICAgICAgICAgIHRoaXMudGFyZ2V0RWwuZGlzcGF0Y2hFdmVudCh0aW1lRm9ybWF0RXJyb3JFdmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJhbmdlRXJyb3IgPSBmYWxzZTsgLy8gY2hlY2sgdGhhdCB0aGUgdGltZSBpbiB3aXRoaW4gYm91bmRzXG5cbiAgICAgICAgaWYgKHNldHRpbmdzLm1pblRpbWUgIT09IG51bGwgJiYgc2V0dGluZ3MubWF4VGltZSAhPT0gbnVsbCAmJiAoc2Vjb25kcyA8IHNldHRpbmdzLm1pblRpbWUoKSB8fCBzZWNvbmRzID4gc2V0dGluZ3MubWF4VGltZSgpKSkge1xuICAgICAgICAgIHJhbmdlRXJyb3IgPSB0cnVlO1xuICAgICAgICB9IC8vIGNoZWNrIHRoYXQgdGltZSBpc24ndCB3aXRoaW4gZGlzYWJsZWQgdGltZSByYW5nZXNcblxuXG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzZXR0aW5ncy5kaXNhYmxlVGltZVJhbmdlcyksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHNlY29uZHMgPj0gcmFuZ2VbMF0gJiYgc2Vjb25kcyA8IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgIHJhbmdlRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5mb3JjZVJvdW5kVGltZSkge1xuICAgICAgICAgIHZhciByb3VuZFNlY29uZHMgPSBzZXR0aW5ncy5yb3VuZGluZ0Z1bmN0aW9uKHNlY29uZHMsIHNldHRpbmdzKTtcblxuICAgICAgICAgIGlmIChyb3VuZFNlY29uZHMgIT0gc2Vjb25kcykge1xuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kU2Vjb25kcztcbiAgICAgICAgICAgIG9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXR0eVRpbWUgPSB0aGlzLl9pbnQydGltZShzZWNvbmRzKTtcblxuICAgICAgICBpZiAocmFuZ2VFcnJvcikge1xuICAgICAgICAgIHRoaXMuX3NldFRpbWVWYWx1ZShwcmV0dHlUaW1lKTtcblxuICAgICAgICAgIHZhciB0aW1lUmFuZ2VFcnJvckV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd0aW1lUmFuZ2VFcnJvcicsIEVWRU5UX0RFRkFVTFRTKTtcbiAgICAgICAgICB0aGlzLnRhcmdldEVsLmRpc3BhdGNoRXZlbnQodGltZVJhbmdlRXJyb3JFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0VGltZVZhbHVlKHByZXR0eVRpbWUsIG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dlbmVyYXRlTm9uZUVsZW1lbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVOb25lRWxlbWVudChvcHRpb25WYWx1ZSwgdXNlU2VsZWN0KSB7XG4gICAgICAgIHZhciBsYWJlbCwgY2xhc3NOYW1lLCB2YWx1ZTtcblxuICAgICAgICBpZiAoX3R5cGVvZihvcHRpb25WYWx1ZSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGxhYmVsID0gb3B0aW9uVmFsdWUubGFiZWw7XG4gICAgICAgICAgY2xhc3NOYW1lID0gb3B0aW9uVmFsdWUuY2xhc3NOYW1lO1xuICAgICAgICAgIHZhbHVlID0gb3B0aW9uVmFsdWUudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBsYWJlbCA9IG9wdGlvblZhbHVlO1xuICAgICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkLmVycm9yKFwiSW52YWxpZCBub25lT3B0aW9uIHZhbHVlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsO1xuXG4gICAgICAgIGlmICh1c2VTZWxlY3QpIHtcbiAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgICBlbC5kYXRhc2V0LnRpbWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuaW5uZXJUZXh0ID0gbGFiZWw7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgICAgLypcbiAgICAgICAqICBUaW1lIHR5cGVhaGVhZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2hhbmRsZUtleVVwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUtleVVwKGUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxpc3QgfHwgIVRpbWVwaWNrZXIuaXNWaXNpYmxlKHRoaXMubGlzdCkgfHwgdGhpcy5zZXR0aW5ncy5kaXNhYmxlVGV4dElucHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS50eXBlID09PSBcInBhc3RlXCIgfHwgZS50eXBlID09PSBcImN1dFwiKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMi5zZXR0aW5ncy50eXBlYWhlYWRIaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9zZXRTZWxlY3RlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmxpc3QuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGhhbmRsZXIsIDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgY2FzZSA5NjogLy8gbnVtcGFkIG51bWVyYWxzXG5cbiAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgIGNhc2UgOTg6XG4gICAgICAgICAgY2FzZSA5OTpcbiAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICBjYXNlIDEwMTpcbiAgICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICBjYXNlIDEwMzpcbiAgICAgICAgICBjYXNlIDEwNDpcbiAgICAgICAgICBjYXNlIDEwNTpcbiAgICAgICAgICBjYXNlIDQ4OiAvLyBudW1lcmFsc1xuXG4gICAgICAgICAgY2FzZSA0OTpcbiAgICAgICAgICBjYXNlIDUwOlxuICAgICAgICAgIGNhc2UgNTE6XG4gICAgICAgICAgY2FzZSA1MjpcbiAgICAgICAgICBjYXNlIDUzOlxuICAgICAgICAgIGNhc2UgNTQ6XG4gICAgICAgICAgY2FzZSA1NTpcbiAgICAgICAgICBjYXNlIDU2OlxuICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgY2FzZSA2NTogLy8gYVxuXG4gICAgICAgICAgY2FzZSA3NzogLy8gbVxuXG4gICAgICAgICAgY2FzZSA4MDogLy8gcFxuXG4gICAgICAgICAgY2FzZSAxODY6IC8vIGNvbG9uXG5cbiAgICAgICAgICBjYXNlIDg6IC8vIGJhY2tzcGFjZVxuXG4gICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgIC8vIGRlbGV0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudHlwZWFoZWFkSGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmxpc3QuaGlkZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcImV4dHJhY3RBdHRyT3B0aW9uc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RBdHRyT3B0aW9ucyhlbGVtZW50LCBrZXlzKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB7fTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGtleXMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChrZXkgaW4gZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICAgICAgICAgIG91dHB1dFtrZXldID0gZWxlbWVudC5kYXRhc2V0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzVmlzaWJsZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmlzaWJsZShlbGVtKSB7XG4gICAgICAgIHZhciBlbCA9IGVsZW1bMF07XG4gICAgICAgIHJldHVybiBlbC5vZmZzZXRXaWR0aCA+IDAgJiYgZWwub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGlkZUFsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVBbGwoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndWktdGltZXBpY2tlci1pbnB1dCcpKSxcbiAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgICB2YXIgdHAgPSBlbC50aW1lcGlja2VyT2JqO1xuXG4gICAgICAgICAgICBpZiAodHApIHtcbiAgICAgICAgICAgICAgdHAuaGlkZU1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUaW1lcGlja2VyO1xuICB9KCk7IC8vIElFOS0xMSBwb2x5ZmlsbCBmb3IgQ3VzdG9tRXZlbnRcblxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oRVZFTlRfREVGQVVMVFMsIHBhcmFtcyk7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgcmV0dXJuIGV2dDtcbiAgICB9XG5cbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAoKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZXhwb3J0cykpID09PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgJiYgKHR5cGVvZiBtb2R1bGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihtb2R1bGUpKSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT09IGV4cG9ydHMpIHtcbiAgICAgIC8vIEJyb3dzZXJpZnkuIEF0dGFjaCB0byBqUXVlcnkgbW9kdWxlLlxuICAgICAgZmFjdG9yeShyZXF1aXJlKFwianF1ZXJ5XCIpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICBkZWZpbmUoW1wianF1ZXJ5XCJdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICBmYWN0b3J5KGpRdWVyeSk7XG4gICAgfVxuICB9KShmdW5jdGlvbiAoJCkge1xuICAgIHZhciBtZXRob2RzID0ge1xuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZWxmID0gJCh0aGlzKTtcbiAgICAgICAgICB2YXIgdHAgPSBuZXcgVGltZXBpY2tlcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB0cC5zZXR0aW5ncztcbiAgICAgICAgICBzZXR0aW5ncy5sYW5nO1xuICAgICAgICAgIHRoaXMudGltZXBpY2tlck9iaiA9IHRwO1xuICAgICAgICAgIHNlbGYuYWRkQ2xhc3MoXCJ1aS10aW1lcGlja2VyLWlucHV0XCIpO1xuXG4gICAgICAgICAgaWYgKHNldHRpbmdzLnVzZVNlbGVjdCkge1xuICAgICAgICAgICAgX3JlbmRlcihzZWxmKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5wcm9wKFwiYXV0b2NvbXBsZXRlXCIsIFwib2ZmXCIpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2hvd09uKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gc2V0dGluZ3Muc2hvd09uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5vbihzZXR0aW5ncy5zaG93T25baV0gKyBcIi50aW1lcGlja2VyXCIsIG1ldGhvZHMuc2hvdyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5vbihcImNoYW5nZS50aW1lcGlja2VyXCIsIHRwLl9oYW5kbGVGb3JtYXRWYWx1ZSk7XG4gICAgICAgICAgICBzZWxmLm9uKFwia2V5ZG93bi50aW1lcGlja2VyXCIsIF9rZXlkb3duaGFuZGxlcik7XG4gICAgICAgICAgICBzZWxmLm9uKFwia2V5dXAudGltZXBpY2tlclwiLCB0cC5faGFuZGxlS2V5VXApO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGlzYWJsZVRleHRJbnB1dCkge1xuICAgICAgICAgICAgICBzZWxmLm9uKFwia2V5ZG93bi50aW1lcGlja2VyXCIsIHRwLl9kaXNhYmxlVGV4dElucHV0SGFuZGxlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYub24oXCJjdXQudGltZXBpY2tlclwiLCB0cC5faGFuZGxlS2V5VXApO1xuICAgICAgICAgICAgc2VsZi5vbihcInBhc3RlLnRpbWVwaWNrZXJcIiwgdHAuX2hhbmRsZUtleVVwKTtcblxuICAgICAgICAgICAgdHAuX2Zvcm1hdFZhbHVlKG51bGwsIFwiaW5pdGlhbFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNob3c6IGZ1bmN0aW9uIHNob3coZSkge1xuICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyk7XG4gICAgICAgIHZhciB0cCA9IHNlbGZbMF0udGltZXBpY2tlck9iajtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdHAuc2V0dGluZ3M7XG5cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0KSB7XG4gICAgICAgICAgdHAubGlzdC50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cC5faGlkZUtleWJvYXJkKCkpIHtcbiAgICAgICAgICAvLyBibG9jayB0aGUga2V5Ym9hcmQgb24gbW9iaWxlIGRldmljZXNcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2JsdXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsaXN0ID0gdHAubGlzdDsgLy8gY2hlY2sgaWYgaW5wdXQgaXMgcmVhZG9ubHlcblxuICAgICAgICBpZiAoc2VsZi5wcm9wKFwicmVhZG9ubHlcIikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gY2hlY2sgaWYgbGlzdCBuZWVkcyB0byBiZSByZW5kZXJlZFxuXG5cbiAgICAgICAgX3JlbmRlcihzZWxmKTtcblxuICAgICAgICBsaXN0ID0gdHAubGlzdDtcblxuICAgICAgICBpZiAoVGltZXBpY2tlci5pc1Zpc2libGUobGlzdCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5pcygnaW5wdXQnKSkge1xuICAgICAgICAgIHRwLnNlbGVjdGVkVmFsdWUgPSBzZWxmLnZhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHAuX3NldFNlbGVjdGVkKCk7IC8vIG1ha2Ugc3VyZSBvdGhlciBwaWNrZXJzIGFyZSBoaWRkZW5cblxuXG4gICAgICAgIFRpbWVwaWNrZXIuaGlkZUFsbCgpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubGlzdFdpZHRoID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBsaXN0LndpZHRoKHNlbGYub3V0ZXJXaWR0aCgpICogc2V0dGluZ3MubGlzdFdpZHRoKTtcbiAgICAgICAgfSAvLyBwb3NpdGlvbiB0aGUgZHJvcGRvd24gcmVsYXRpdmUgdG8gdGhlIGlucHV0XG5cblxuICAgICAgICBsaXN0LnNob3coKTtcbiAgICAgICAgdmFyIGxpc3RPZmZzZXQgPSB7fTtcblxuICAgICAgICBpZiAoc2V0dGluZ3Mub3JpZW50YXRpb24ubWF0Y2goL3IvKSkge1xuICAgICAgICAgIC8vIHJpZ2h0LWFsaWduIHRoZSBkcm9wZG93blxuICAgICAgICAgIGxpc3RPZmZzZXQubGVmdCA9IHNlbGYub2Zmc2V0KCkubGVmdCArIHNlbGYub3V0ZXJXaWR0aCgpIC0gbGlzdC5vdXRlcldpZHRoKCkgKyBwYXJzZUludChsaXN0LmNzcyhcIm1hcmdpbkxlZnRcIikucmVwbGFjZShcInB4XCIsIFwiXCIpLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mub3JpZW50YXRpb24ubWF0Y2goL2wvKSkge1xuICAgICAgICAgIC8vIGxlZnQtYWxpZ24gdGhlIGRyb3Bkb3duXG4gICAgICAgICAgbGlzdE9mZnNldC5sZWZ0ID0gc2VsZi5vZmZzZXQoKS5sZWZ0ICsgcGFyc2VJbnQobGlzdC5jc3MoXCJtYXJnaW5MZWZ0XCIpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9yaWVudGF0aW9uLm1hdGNoKC9jLykpIHtcbiAgICAgICAgICAvLyBjZW50ZXItYWxpZ24gdGhlIGRyb3Bkb3duXG4gICAgICAgICAgbGlzdE9mZnNldC5sZWZ0ID0gc2VsZi5vZmZzZXQoKS5sZWZ0ICsgKHNlbGYub3V0ZXJXaWR0aCgpIC0gbGlzdC5vdXRlcldpZHRoKCkpIC8gMiArIHBhcnNlSW50KGxpc3QuY3NzKFwibWFyZ2luTGVmdFwiKS5yZXBsYWNlKFwicHhcIiwgXCJcIiksIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0aWNhbE9yaWVudGF0aW9uO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5vcmllbnRhdGlvbi5tYXRjaCgvdC8pKSB7XG4gICAgICAgICAgdmVydGljYWxPcmllbnRhdGlvbiA9IFwidFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9yaWVudGF0aW9uLm1hdGNoKC9iLykpIHtcbiAgICAgICAgICB2ZXJ0aWNhbE9yaWVudGF0aW9uID0gXCJiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5vZmZzZXQoKS50b3AgKyBzZWxmLm91dGVySGVpZ2h0KHRydWUpICsgbGlzdC5vdXRlckhlaWdodCgpID4gJCh3aW5kb3cpLmhlaWdodCgpICsgJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSB7XG4gICAgICAgICAgdmVydGljYWxPcmllbnRhdGlvbiA9IFwidFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlcnRpY2FsT3JpZW50YXRpb24gPSBcImJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ZXJ0aWNhbE9yaWVudGF0aW9uID09IFwidFwiKSB7XG4gICAgICAgICAgLy8gcG9zaXRpb24gdGhlIGRyb3Bkb3duIG9uIHRvcFxuICAgICAgICAgIGxpc3QuYWRkQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXBvc2l0aW9uZWQtdG9wXCIpO1xuICAgICAgICAgIGxpc3RPZmZzZXQudG9wID0gc2VsZi5vZmZzZXQoKS50b3AgLSBsaXN0Lm91dGVySGVpZ2h0KCkgKyBwYXJzZUludChsaXN0LmNzcyhcIm1hcmdpblRvcFwiKS5yZXBsYWNlKFwicHhcIiwgXCJcIiksIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwdXQgaXQgdW5kZXIgdGhlIGlucHV0XG4gICAgICAgICAgbGlzdC5yZW1vdmVDbGFzcyhcInVpLXRpbWVwaWNrZXItcG9zaXRpb25lZC10b3BcIik7XG4gICAgICAgICAgbGlzdE9mZnNldC50b3AgPSBzZWxmLm9mZnNldCgpLnRvcCArIHNlbGYub3V0ZXJIZWlnaHQoKSArIHBhcnNlSW50KGxpc3QuY3NzKFwibWFyZ2luVG9wXCIpLnJlcGxhY2UoXCJweFwiLCBcIlwiKSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5vZmZzZXQobGlzdE9mZnNldCk7IC8vIHBvc2l0aW9uIHNjcm9sbGluZ1xuXG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGxpc3QuZmluZChcIi51aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuXG4gICAgICAgIGlmICghc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHRpbWVJbnQgPSB0cC5hbnl0aW1lMmludCh0cC5fZ2V0VGltZVZhbHVlKCkpO1xuXG4gICAgICAgICAgaWYgKHRpbWVJbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gJCh0cC5fZmluZFJvdyh0aW1lSW50KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zY3JvbGxEZWZhdWx0KCkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gJCh0cC5fZmluZFJvdyhzZXR0aW5ncy5zY3JvbGxEZWZhdWx0KCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgbm90IGZvdW5kIG9yIGRpc2FibGVkLCBpbnRlbGxpZ2VudGx5IGZpbmQgZmlyc3Qgc2VsZWN0YWJsZSBlbGVtZW50XG5cblxuICAgICAgICBpZiAoIXNlbGVjdGVkLmxlbmd0aCB8fCBzZWxlY3RlZC5oYXNDbGFzcyhcInVpLXRpbWVwaWNrZXItZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICBzZWxlY3RlZCA9IGxpc3QuZmluZChcImxpOm5vdCgudWktdGltZXBpY2tlci1kaXNhYmxlZCk6Zmlyc3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHRvcE9mZnNldCA9IGxpc3Quc2Nyb2xsVG9wKCkgKyBzZWxlY3RlZC5wb3NpdGlvbigpLnRvcCAtIHNlbGVjdGVkLm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgbGlzdC5zY3JvbGxUb3AodG9wT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0LnNjcm9sbFRvcCgwKTtcbiAgICAgICAgfSAvLyBwcmV2ZW50IHNjcm9sbCBwcm9wYWdhdGlvblxuXG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnN0b3BTY3JvbGxQcm9wYWdhdGlvbikge1xuICAgICAgICAgICQoZG9jdW1lbnQpLm9uKFwid2hlZWwudWktdGltZXBpY2tlclwiLCBcIi51aS10aW1lcGlja2VyLXdyYXBwZXJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2Nyb2xsID0gJCh0aGlzKS5zY3JvbGxUb3AoKTtcbiAgICAgICAgICAgICQodGhpcykuc2Nyb2xsVG9wKGN1cnJlbnRTY3JvbGwgKyBlLm9yaWdpbmFsRXZlbnQuZGVsdGFZKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBhdHRhY2ggY2xvc2UgaGFuZGxlcnNcblxuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKFwibW91c2Vkb3duLnVpLXRpbWVwaWNrZXJcIiwgX2Nsb3NlSGFuZGxlcik7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBfY2xvc2VIYW5kbGVyKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuY2xvc2VPbldpbmRvd1Njcm9sbCkge1xuICAgICAgICAgICQoZG9jdW1lbnQpLm9uKFwic2Nyb2xsLnVpLXRpbWVwaWNrZXJcIiwgX2Nsb3NlSGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnRyaWdnZXIoXCJzaG93VGltZXBpY2tlclwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZShlKSB7XG4gICAgICAgIHZhciB0cCA9IHRoaXNbMF0udGltZXBpY2tlck9iajtcblxuICAgICAgICBpZiAodHApIHtcbiAgICAgICAgICB0cC5oaWRlTWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFRpbWVwaWNrZXIuaGlkZUFsbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBvcHRpb246IGZ1bmN0aW9uIG9wdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB2YXIgdHAgPSB0aGlzWzBdLnRpbWVwaWNrZXJPYmo7XG4gICAgICAgICAgcmV0dXJuIHRwLnNldHRpbmdzW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyk7XG4gICAgICAgICAgdmFyIHRwID0gc2VsZlswXS50aW1lcGlja2VyT2JqO1xuICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHRwLnNldHRpbmdzO1xuICAgICAgICAgIHZhciBsaXN0ID0gdHAubGlzdDtcblxuICAgICAgICAgIGlmIChfdHlwZW9mKGtleSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywga2V5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldHRpbmdzID0gdHAucGFyc2VTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgICAgdHAuc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAgICAgICAgIHRwLl9mb3JtYXRWYWx1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImNoYW5nZVwiXG4gICAgICAgICAgfSwgXCJpbml0aWFsXCIpO1xuXG4gICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgIGxpc3QucmVtb3ZlKCk7XG4gICAgICAgICAgICB0cC5saXN0ID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0KSB7XG4gICAgICAgICAgICBfcmVuZGVyKHNlbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2V0U2Vjb25kc0Zyb21NaWRuaWdodDogZnVuY3Rpb24gZ2V0U2Vjb25kc0Zyb21NaWRuaWdodCgpIHtcbiAgICAgICAgdmFyIHRwID0gdGhpc1swXS50aW1lcGlja2VyT2JqO1xuICAgICAgICByZXR1cm4gdHAuYW55dGltZTJpbnQodHAuX2dldFRpbWVWYWx1ZSgpKTtcbiAgICAgIH0sXG4gICAgICBnZXRUaW1lOiBmdW5jdGlvbiBnZXRUaW1lKHJlbGF0aXZlX2RhdGUpIHtcbiAgICAgICAgdmFyIHRwID0gdGhpc1swXS50aW1lcGlja2VyT2JqO1xuXG4gICAgICAgIHZhciB0aW1lX3N0cmluZyA9IHRwLl9nZXRUaW1lVmFsdWUoKTtcblxuICAgICAgICBpZiAoIXRpbWVfc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gdHAuYW55dGltZTJpbnQodGltZV9zdHJpbmcpO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVsYXRpdmVfZGF0ZSkge1xuICAgICAgICAgIHJlbGF0aXZlX2RhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9IC8vIGNvbnN0cnVjdCBhIERhdGUgZnJvbSByZWxhdGl2ZSBkYXRlLCBhbmQgb2Zmc2V0J3MgdGltZVxuXG5cbiAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZShyZWxhdGl2ZV9kYXRlKTtcbiAgICAgICAgdGltZS5zZXRIb3VycyhvZmZzZXQgLyAzNjAwKTtcbiAgICAgICAgdGltZS5zZXRNaW51dGVzKG9mZnNldCAlIDM2MDAgLyA2MCk7XG4gICAgICAgIHRpbWUuc2V0U2Vjb25kcyhvZmZzZXQgJSA2MCk7XG4gICAgICAgIHRpbWUuc2V0TWlsbGlzZWNvbmRzKDApO1xuICAgICAgICByZXR1cm4gdGltZTtcbiAgICAgIH0sXG4gICAgICBpc1Zpc2libGU6IGZ1bmN0aW9uIGlzVmlzaWJsZSgpIHtcbiAgICAgICAgdmFyIHRwID0gdGhpc1swXS50aW1lcGlja2VyT2JqO1xuICAgICAgICByZXR1cm4gISEodHAgJiYgdHAubGlzdCAmJiBUaW1lcGlja2VyLmlzVmlzaWJsZSh0cC5saXN0KSk7XG4gICAgICB9LFxuICAgICAgc2V0VGltZTogZnVuY3Rpb24gc2V0VGltZSh2YWx1ZSkge1xuICAgICAgICB2YXIgdHAgPSB0aGlzWzBdLnRpbWVwaWNrZXJPYmo7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRwLnNldHRpbmdzO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5mb3JjZVJvdW5kVGltZSkge1xuICAgICAgICAgIHZhciBwcmV0dHlUaW1lID0gdHAuX3JvdW5kQW5kRm9ybWF0VGltZSh0cC5hbnl0aW1lMmludCh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV0dHlUaW1lID0gdHAuX2ludDJ0aW1lKHRwLmFueXRpbWUyaW50KHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgJiYgcHJldHR5VGltZSA9PT0gbnVsbCAmJiBzZXR0aW5ncy5ub25lT3B0aW9uKSB7XG4gICAgICAgICAgcHJldHR5VGltZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHAuX3NldFRpbWVWYWx1ZShwcmV0dHlUaW1lLCBcImluaXRpYWxcIik7XG5cbiAgICAgICAgdHAuX2Zvcm1hdFZhbHVlKHtcbiAgICAgICAgICB0eXBlOiBcImNoYW5nZVwiXG4gICAgICAgIH0sIFwiaW5pdGlhbFwiKTtcblxuICAgICAgICBpZiAodHAgJiYgdHAubGlzdCkge1xuICAgICAgICAgIHRwLl9zZXRTZWxlY3RlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpczsgLy8gY2hlY2sgaWYgdGhpcyBlbGVtZW50IGlzIGEgdGltZXBpY2tlclxuXG4gICAgICAgIGlmICghc2VsZi5oYXNDbGFzcyhcInVpLXRpbWVwaWNrZXItaW5wdXRcIikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHAgPSBzZWxmWzBdLnRpbWVwaWNrZXJPYmo7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRwLnNldHRpbmdzO1xuICAgICAgICBzZWxmLnJlbW92ZUF0dHIoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIik7XG4gICAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoXCJ1aS10aW1lcGlja2VyLWlucHV0XCIpO1xuICAgICAgICBzZWxmLnJlbW92ZURhdGEoXCJ0aW1lcGlja2VyLW9ialwiKTtcbiAgICAgICAgc2VsZi5vZmYoXCIudGltZXBpY2tlclwiKTsgLy8gdGltZXBpY2tlci1saXN0IHdvbid0IGJlIHByZXNlbnQgdW5sZXNzIHRoZSB1c2VyIGhhcyBpbnRlcmFjdGVkIHdpdGggdGhpcyB0aW1lcGlja2VyXG5cbiAgICAgICAgaWYgKHRwLmxpc3QpIHtcbiAgICAgICAgICB0cC5saXN0LnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnVzZVNlbGVjdCkge1xuICAgICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHAubGlzdCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07IC8vIHByaXZhdGUgbWV0aG9kc1xuXG4gICAgZnVuY3Rpb24gX3JlbmRlcihzZWxmKSB7XG4gICAgICB2YXIgX3NldHRpbmdzJGR1cmF0aW9uVGltLCBfc2V0dGluZ3MkbWluVGltZSwgX3NldHRpbmdzJG1heFRpbWU7XG5cbiAgICAgIHZhciB0cCA9IHNlbGZbMF0udGltZXBpY2tlck9iajtcbiAgICAgIHZhciBsaXN0ID0gdHAubGlzdDtcbiAgICAgIHZhciBzZXR0aW5ncyA9IHRwLnNldHRpbmdzO1xuXG4gICAgICBpZiAobGlzdCAmJiBsaXN0Lmxlbmd0aCkge1xuICAgICAgICBsaXN0LnJlbW92ZSgpO1xuICAgICAgICB0cC5saXN0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLnVzZVNlbGVjdCkge1xuICAgICAgICBsaXN0ID0gJChcIjxzZWxlY3Q+PC9zZWxlY3Q+XCIsIHtcbiAgICAgICAgICBcImNsYXNzXCI6IFwidWktdGltZXBpY2tlci1zZWxlY3RcIlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZi5hdHRyKFwibmFtZVwiKSkge1xuICAgICAgICAgIGxpc3QuYXR0cihcIm5hbWVcIiwgXCJ1aS10aW1lcGlja2VyLVwiICsgc2VsZi5hdHRyKFwibmFtZVwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd3JhcHBlZF9saXN0ID0gbGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QgPSAkKFwiPHVsPjwvdWw+XCIsIHtcbiAgICAgICAgICBcImNsYXNzXCI6IFwidWktdGltZXBpY2tlci1saXN0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB3cmFwcGVkX2xpc3QgPSAkKFwiPGRpdj48L2Rpdj5cIiwge1xuICAgICAgICAgIFwiY2xhc3NcIjogXCJ1aS10aW1lcGlja2VyLXdyYXBwZXJcIixcbiAgICAgICAgICB0YWJpbmRleDogLTFcbiAgICAgICAgfSk7XG4gICAgICAgIHdyYXBwZWRfbGlzdC5jc3Moe1xuICAgICAgICAgIGRpc3BsYXk6IFwibm9uZVwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgICAgfSkuYXBwZW5kKGxpc3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0dGluZ3Mubm9uZU9wdGlvbikge1xuICAgICAgICBpZiAoc2V0dGluZ3Mubm9uZU9wdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNldHRpbmdzLm5vbmVPcHRpb24gPSBzZXR0aW5ncy51c2VTZWxlY3QgPyBcIlRpbWUuLi5cIiA6IFwiTm9uZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCQuaXNBcnJheShzZXR0aW5ncy5ub25lT3B0aW9uKSkge1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gc2V0dGluZ3Mubm9uZU9wdGlvbikge1xuICAgICAgICAgICAgaWYgKHBhcnNlSW50KGksIDEwKSA9PSBpKSB7XG4gICAgICAgICAgICAgIHZhciBub25lRWxlbWVudCA9IHRwLl9nZW5lcmF0ZU5vbmVFbGVtZW50KHNldHRpbmdzLm5vbmVPcHRpb25baV0sIHNldHRpbmdzLnVzZVNlbGVjdCk7XG5cbiAgICAgICAgICAgICAgbGlzdC5hcHBlbmQobm9uZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9uZUVsZW1lbnQgPSB0cC5fZ2VuZXJhdGVOb25lRWxlbWVudChzZXR0aW5ncy5ub25lT3B0aW9uLCBzZXR0aW5ncy51c2VTZWxlY3QpO1xuXG4gICAgICAgICAgbGlzdC5hcHBlbmQobm9uZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXR0aW5ncy5jbGFzc05hbWUpIHtcbiAgICAgICAgd3JhcHBlZF9saXN0LmFkZENsYXNzKHNldHRpbmdzLmNsYXNzTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoc2V0dGluZ3MubWluVGltZSAhPT0gbnVsbCB8fCBzZXR0aW5ncy5kdXJhdGlvblRpbWUgIT09IG51bGwpICYmIHNldHRpbmdzLnNob3dEdXJhdGlvbikge1xuICAgICAgICB0eXBlb2Ygc2V0dGluZ3Muc3RlcCA9PSBcImZ1bmN0aW9uXCIgPyBcImZ1bmN0aW9uXCIgOiBzZXR0aW5ncy5zdGVwO1xuICAgICAgICB3cmFwcGVkX2xpc3QuYWRkQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXdpdGgtZHVyYXRpb25cIik7XG4gICAgICAgIHdyYXBwZWRfbGlzdC5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItc3RlcC1cIiArIHNldHRpbmdzLnN0ZXApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyU3RhcnQgPSAoX3NldHRpbmdzJGR1cmF0aW9uVGltID0gc2V0dGluZ3MuZHVyYXRpb25UaW1lKCkpICE9PSBudWxsICYmIF9zZXR0aW5ncyRkdXJhdGlvblRpbSAhPT0gdm9pZCAwID8gX3NldHRpbmdzJGR1cmF0aW9uVGltIDogc2V0dGluZ3MubWluVGltZSgpO1xuICAgICAgdmFyIHN0YXJ0ID0gKF9zZXR0aW5ncyRtaW5UaW1lID0gc2V0dGluZ3MubWluVGltZSgpKSAhPT0gbnVsbCAmJiBfc2V0dGluZ3MkbWluVGltZSAhPT0gdm9pZCAwID8gX3NldHRpbmdzJG1pblRpbWUgOiAwO1xuICAgICAgdmFyIGVuZCA9IChfc2V0dGluZ3MkbWF4VGltZSA9IHNldHRpbmdzLm1heFRpbWUoKSkgIT09IG51bGwgJiYgX3NldHRpbmdzJG1heFRpbWUgIT09IHZvaWQgMCA/IF9zZXR0aW5ncyRtYXhUaW1lIDogc3RhcnQgKyBPTkVfREFZIC0gMTtcblxuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgZW5kIHRpbWUgaXMgZ3JlYXRlciB0aGFuIHN0YXJ0IHRpbWUsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG5vIGxpc3QgdG8gc2hvd1xuICAgICAgICBlbmQgKz0gT05FX0RBWTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gT05FX0RBWSAtIDEgJiYgJC50eXBlKHNldHRpbmdzLnRpbWVGb3JtYXQpID09PSBcInN0cmluZ1wiICYmIHNldHRpbmdzLnNob3cyNDAwKSB7XG4gICAgICAgIC8vIHNob3cgYSAyNDowMCBvcHRpb24gd2hlbiB1c2luZyBtaWxpdGFyeSB0aW1lXG4gICAgICAgIGVuZCA9IE9ORV9EQVk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkciA9IHNldHRpbmdzLmRpc2FibGVUaW1lUmFuZ2VzO1xuICAgICAgdmFyIGRyQ3VyID0gMDtcbiAgICAgIHZhciBkckxlbiA9IGRyLmxlbmd0aDtcbiAgICAgIHZhciBzdGVwRnVuYyA9IHNldHRpbmdzLnN0ZXA7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3RlcEZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHN0ZXBGdW5jID0gZnVuY3Rpb24gc3RlcEZ1bmMoKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnN0ZXA7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IDA7IGkgPD0gZW5kOyBqKyssIGkgKz0gc3RlcEZ1bmMoaikgKiA2MCkge1xuICAgICAgICB2YXIgdGltZUludCA9IGk7XG5cbiAgICAgICAgdmFyIHRpbWVTdHJpbmcgPSB0cC5faW50MnRpbWUodGltZUludCk7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnVzZVNlbGVjdCkge1xuICAgICAgICAgIHZhciByb3cgPSAkKFwiPG9wdGlvbj48L29wdGlvbj5cIiwge1xuICAgICAgICAgICAgdmFsdWU6IHRpbWVTdHJpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByb3cudGV4dCh0aW1lU3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm93ID0gJChcIjxsaT48L2xpPlwiKTtcbiAgICAgICAgICByb3cuYWRkQ2xhc3ModGltZUludCAlIE9ORV9EQVkgPCBPTkVfREFZIC8gMiA/IFwidWktdGltZXBpY2tlci1hbVwiIDogXCJ1aS10aW1lcGlja2VyLXBtXCIpO1xuICAgICAgICAgIHJvdy5hdHRyKFwiZGF0YS10aW1lXCIsIHJvdW5kaW5nRnVuY3Rpb24odGltZUludCwgc2V0dGluZ3MpKTtcbiAgICAgICAgICByb3cudGV4dCh0aW1lU3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoc2V0dGluZ3MubWluVGltZSgpICE9PSBudWxsIHx8IHNldHRpbmdzLmR1cmF0aW9uVGltZSgpICE9PSBudWxsKSAmJiBzZXR0aW5ncy5zaG93RHVyYXRpb24pIHtcbiAgICAgICAgICB2YXIgZHVyYXRpb25TdHJpbmcgPSB0cC5faW50MmR1cmF0aW9uKGkgLSBkdXJTdGFydCwgc2V0dGluZ3Muc3RlcCk7XG5cbiAgICAgICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0KSB7XG4gICAgICAgICAgICByb3cudGV4dChyb3cudGV4dCgpICsgXCIgKFwiICsgZHVyYXRpb25TdHJpbmcgKyBcIilcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9ICQoXCI8c3Bhbj48L3NwYW4+XCIsIHtcbiAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcInVpLXRpbWVwaWNrZXItZHVyYXRpb25cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkdXJhdGlvbi50ZXh0KFwiIChcIiArIGR1cmF0aW9uU3RyaW5nICsgXCIpXCIpO1xuICAgICAgICAgICAgcm93LmFwcGVuZChkdXJhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyQ3VyIDwgZHJMZW4pIHtcbiAgICAgICAgICBpZiAodGltZUludCA+PSBkcltkckN1cl1bMV0pIHtcbiAgICAgICAgICAgIGRyQ3VyICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRyW2RyQ3VyXSAmJiB0aW1lSW50ID49IGRyW2RyQ3VyXVswXSAmJiB0aW1lSW50IDwgZHJbZHJDdXJdWzFdKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MudXNlU2VsZWN0KSB7XG4gICAgICAgICAgICAgIHJvdy5wcm9wKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByb3cuYWRkQ2xhc3MoXCJ1aS10aW1lcGlja2VyLWRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QuYXBwZW5kKHJvdyk7XG4gICAgICB9XG5cbiAgICAgIHdyYXBwZWRfbGlzdC5kYXRhKFwidGltZXBpY2tlci1pbnB1dFwiLCBzZWxmKTtcbiAgICAgIHRwLmxpc3QgPSB3cmFwcGVkX2xpc3Q7XG5cbiAgICAgIGlmIChzZXR0aW5ncy51c2VTZWxlY3QpIHtcbiAgICAgICAgaWYgKHNlbGYudmFsKCkpIHtcbiAgICAgICAgICBsaXN0LnZhbCh0cC5fcm91bmRBbmRGb3JtYXRUaW1lKHRwLmFueXRpbWUyaW50KHNlbGYudmFsKCkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0Lm9uKFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQodGhpcykuZGF0YShcInRpbWVwaWNrZXItaW5wdXRcIikudHJpZ2dlcihcInNob3dUaW1lcGlja2VyXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdC5vbihcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQodGhpcykuZGF0YShcInRpbWVwaWNrZXItaW5wdXRcIikudHJpZ2dlcihcImhpZGVUaW1lcGlja2VyXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlzdC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHAuX3NldFRpbWVWYWx1ZSgkKHRoaXMpLnZhbCgpLCBcInNlbGVjdFwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdHAuX3NldFRpbWVWYWx1ZShsaXN0LnZhbCgpLCBcImluaXRpYWxcIik7XG5cbiAgICAgICAgc2VsZi5oaWRlKCkuYWZ0ZXIobGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXBwZW5kVG8gPSBzZXR0aW5ncy5hcHBlbmRUbztcblxuICAgICAgICBpZiAodHlwZW9mIGFwcGVuZFRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgYXBwZW5kVG8gPSAkKGFwcGVuZFRvKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXBwZW5kVG8gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGFwcGVuZFRvID0gYXBwZW5kVG8oc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRUby5hcHBlbmQod3JhcHBlZF9saXN0KTtcblxuICAgICAgICB0cC5fc2V0U2VsZWN0ZWQoKTtcblxuICAgICAgICBsaXN0Lm9uKFwibW91c2Vkb3duIGNsaWNrXCIsIFwibGlcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBoYWNrOiB0ZW1wb3JhcmlseSBkaXNhYmxlIHRoZSBmb2N1cyBoYW5kbGVyXG4gICAgICAgICAgLy8gdG8gZGVhbCB3aXRoIHRoZSBmYWN0IHRoYXQgSUUgZmlyZXMgJ2ZvY3VzJ1xuICAgICAgICAgIC8vIGV2ZW50cyBhc3luY2hyb25vdXNseVxuICAgICAgICAgIHNlbGYub2ZmKFwiZm9jdXMudGltZXBpY2tlclwiKTtcbiAgICAgICAgICBzZWxmLm9uKFwiZm9jdXMudGltZXBpY2tlci1pZS1oYWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub2ZmKFwiZm9jdXMudGltZXBpY2tlci1pZS1oYWNrXCIpO1xuICAgICAgICAgICAgc2VsZi5vbihcImZvY3VzLnRpbWVwaWNrZXJcIiwgbWV0aG9kcy5zaG93KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghdHAuX2hpZGVLZXlib2FyZCgpKSB7XG4gICAgICAgICAgICBzZWxmWzBdLmZvY3VzKCk7XG4gICAgICAgICAgfSAvLyBtYWtlIHN1cmUgb25seSB0aGUgY2xpY2tlZCByb3cgaXMgc2VsZWN0ZWRcblxuXG4gICAgICAgICAgbGlzdC5maW5kKFwibGlcIikucmVtb3ZlQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuXG4gICAgICAgICAgaWYgKHRwLl9zZWxlY3RWYWx1ZSgpKSB7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoXCJoaWRlVGltZXBpY2tlclwiKTtcbiAgICAgICAgICAgIGxpc3Qub24oXCJtb3VzZXVwLnRpbWVwaWNrZXIgY2xpY2sudGltZXBpY2tlclwiLCBcImxpXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGxpc3Qub2ZmKFwibW91c2V1cC50aW1lcGlja2VyIGNsaWNrLnRpbWVwaWNrZXJcIik7XG4gICAgICAgICAgICAgIHdyYXBwZWRfbGlzdC5oaWRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gZXZlbnQgaGFuZGxlciB0byBkZWNpZGUgd2hldGhlciB0byBjbG9zZSB0aW1lcGlja2VyXG5cblxuICAgIGZ1bmN0aW9uIF9jbG9zZUhhbmRsZXIoZSkge1xuICAgICAgaWYgKGUudHlwZSA9PSAnZm9jdXMnICYmIGUudGFyZ2V0ID09IHdpbmRvdykge1xuICAgICAgICAvLyBtb2JpbGUgQ2hyb21lIGZpcmVzIGZvY3VzIGV2ZW50cyBhZ2FpbnN0IHdpbmRvdyBmb3Igc29tZSByZWFzb25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0ID0gJChlLnRhcmdldCk7XG5cbiAgICAgIGlmICh0YXJnZXQuY2xvc2VzdChcIi51aS10aW1lcGlja2VyLWlucHV0XCIpLmxlbmd0aCB8fCB0YXJnZXQuY2xvc2VzdChcIi51aS10aW1lcGlja2VyLXdyYXBwZXJcIikubGVuZ3RoKSB7XG4gICAgICAgIC8vIGFjdGl2ZSB0aW1lcGlja2VyIHdhcyBmb2N1c2VkLiBpZ25vcmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBUaW1lcGlja2VyLmhpZGVBbGwoKTtcbiAgICAgICQoZG9jdW1lbnQpLnVuYmluZChcIi51aS10aW1lcGlja2VyXCIpO1xuICAgICAgJCh3aW5kb3cpLnVuYmluZChcIi51aS10aW1lcGlja2VyXCIpO1xuICAgIH1cbiAgICAvKlxuICAgICAqICBLZXlib2FyZCBuYXZpZ2F0aW9uIHZpYSBhcnJvdyBrZXlzXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIF9rZXlkb3duaGFuZGxlcihlKSB7XG4gICAgICB2YXIgc2VsZiA9ICQodGhpcyk7XG4gICAgICB2YXIgdHAgPSBzZWxmWzBdLnRpbWVwaWNrZXJPYmo7XG4gICAgICB2YXIgbGlzdCA9IHRwLmxpc3Q7XG5cbiAgICAgIGlmICghbGlzdCB8fCAhVGltZXBpY2tlci5pc1Zpc2libGUobGlzdCkpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSA0MCkge1xuICAgICAgICAgIC8vIHNob3cgdGhlIGxpc3QhXG4gICAgICAgICAgbWV0aG9kcy5zaG93LmNhbGwoc2VsZi5nZXQoMCkpO1xuICAgICAgICAgIGxpc3QgPSB0cC5saXN0O1xuXG4gICAgICAgICAgaWYgKCF0cC5faGlkZUtleWJvYXJkKCkpIHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAvLyByZXR1cm5cbiAgICAgICAgICBpZiAodHAuX3NlbGVjdFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRwLl9mb3JtYXRWYWx1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiY2hhbmdlXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0cC5oaWRlTWUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgLy8gdXBcbiAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBsaXN0LmZpbmQoXCIudWktdGltZXBpY2tlci1zZWxlY3RlZFwiKTtcblxuICAgICAgICAgIGlmICghc2VsZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBsaXN0LmZpbmQoXCJsaVwiKS5lYWNoKGZ1bmN0aW9uIChpLCBvYmopIHtcbiAgICAgICAgICAgICAgaWYgKCQob2JqKS5wb3NpdGlvbigpLnRvcCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9ICQob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWQuYWRkQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXNlbGVjdGVkLmlzKFwiOmZpcnN0LWNoaWxkXCIpKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5yZW1vdmVDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICBzZWxlY3RlZC5wcmV2KCkuYWRkQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQucHJldigpLnBvc2l0aW9uKCkudG9wIDwgc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKSkge1xuICAgICAgICAgICAgICBsaXN0LnNjcm9sbFRvcChsaXN0LnNjcm9sbFRvcCgpIC0gc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgLy8gZG93blxuICAgICAgICAgIHNlbGVjdGVkID0gbGlzdC5maW5kKFwiLnVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsaXN0LmZpbmQoXCJsaVwiKS5lYWNoKGZ1bmN0aW9uIChpLCBvYmopIHtcbiAgICAgICAgICAgICAgaWYgKCQob2JqKS5wb3NpdGlvbigpLnRvcCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9ICQob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWQuYWRkQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXNlbGVjdGVkLmlzKFwiOmxhc3QtY2hpbGRcIikpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnJlbW92ZUNsYXNzKFwidWktdGltZXBpY2tlci1zZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIHNlbGVjdGVkLm5leHQoKS5hZGRDbGFzcyhcInVpLXRpbWVwaWNrZXItc2VsZWN0ZWRcIik7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZC5uZXh0KCkucG9zaXRpb24oKS50b3AgKyAyICogc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKSA+IGxpc3Qub3V0ZXJIZWlnaHQoKSkge1xuICAgICAgICAgICAgICBsaXN0LnNjcm9sbFRvcChsaXN0LnNjcm9sbFRvcCgpICsgc2VsZWN0ZWQub3V0ZXJIZWlnaHQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgLy8gZXNjYXBlXG4gICAgICAgICAgbGlzdC5maW5kKFwibGlcIikucmVtb3ZlQ2xhc3MoXCJ1aS10aW1lcGlja2VyLXNlbGVjdGVkXCIpO1xuICAgICAgICAgIHRwLmhpZGVNZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAvL3RhYlxuICAgICAgICAgIHRwLmhpZGVNZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBQbHVnaW4gZW50cnlcblxuXG4gICAgJC5mbi50aW1lcGlja2VyID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChtZXRob2RzW21ldGhvZF0pIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBlbGVtZW50IGlzIGEgdGltZXBpY2tlclxuICAgICAgICBpZiAoIXRoaXMuaGFzQ2xhc3MoXCJ1aS10aW1lcGlja2VyLWlucHV0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG1ldGhvZCkgPT09IFwib2JqZWN0XCIgfHwgIW1ldGhvZCkge1xuICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkLmVycm9yKFwiTWV0aG9kIFwiICsgbWV0aG9kICsgXCIgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5LnRpbWVwaWNrZXJcIik7XG4gICAgICB9XG4gICAgfTsgLy8gRGVmYXVsdCBwbHVnaW4gb3B0aW9ucy5cblxuXG4gICAgJC5mbi50aW1lcGlja2VyLmRlZmF1bHRzID0gREVGQVVMVF9TRVRUSU5HUztcbiAgfSk7XG5cbn0oKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/timepicker/jquery.timepicker.js\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ (function(module) {

"use strict";
module.exports = window["jQuery"];

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/jquery-timepicker/jquery-timepicker.js");
/******/ 	var __webpack_export_target__ = window;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;